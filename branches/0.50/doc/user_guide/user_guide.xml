<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
   <bookinfo>
      <title>vrkit</title>

      <subtitle>User's Guide</subtitle>

      <copyright>
         <year>2007â€“2008</year>

         <holder>Allen Bierbaum, Aron Bierbaum, Patrick Hartling, and Daniel
         Shipton</holder>
      </copyright>

      <author>
         <surname>Patrick Hartling</surname>
      </author>

      <legalnotice>
         <para>Permission is granted to copy, distribute and/or modify this
         document under the terms of the GNU Free Documentation License,
         Version 1.2 or any later version published by the Free Software
         Foundation; with the Invariant Sections being <xref
         linkend="appendix.gfdl" />, with no Front-Cover Texts, and with no
         Back-Cover Texts. A copy of the license is included in <xref
         linkend="appendix.gfdl" />.</para>
      </legalnotice>

      <releaseinfo>Version 0.50</releaseinfo>

      <pubdate>$Date: 2007-08-21 19:55:29 -0500 (Tue, 21 Aug 2007) $</pubdate>
   </bookinfo>

   <preface>
      <title>Preface</title>

      <para>In this book, we present vrkit, an open source software package
      designed to facilitate rapid creation of powerful, feature-rich virtual
      reality (VR) applications based on VR Juggler and OpenSG. Ideally, all
      application features are composed at run time using plug-ins, each of
      which captures some specific piece of functionality (scene navigation,
      object grabbing, video capture, and so on). vrkit is built on other
      tools, and learning about those other tools is essential to
      understanding vrkit and to using it to its fullest potential. The
      following are some useful starting points.</para>

      <itemizedlist>
         <listitem>
            <para><ulink
            url="http://realityforge.vrsource.org/trac/vrkit/">vrkit
            website</ulink></para>
         </listitem>

         <listitem>
            <para><ulink url="http://www.vrjuggler.org/documentation.php">VR
            Juggler documentation</ulink></para>
         </listitem>

         <listitem>
            <para><ulink url="http://opensg.vrsource.org/">OpenSG
            website</ulink></para>
         </listitem>
      </itemizedlist>

      <para>More specifically, the VR Juggler <emphasis>Getting Started
      Guide</emphasis> is required reading, and the VR Juggler
      <emphasis>Configuration Guide</emphasis> is at the top of the list of
      recommended reading.</para>

      <section>
         <title>Environment Variables</title>

         <para>In addition to environment variables related to VR Juggler (see
         the VR Juggler <emphasis>Getting Started Guide</emphasis>) and
         OpenSG, vrkit makes use of a few environment variables. We start by
         providing a brief overview of the way that environment variables are
         addressed in this book before we describe the vrkit environment
         variables. This information is the same as is presented in the VR
         Juggler <emphasis>Getting Started Guide</emphasis>, so readers
         already familiar with those conventions can skip to <xref
         linkend="section.envvars.vrkit" />.</para>

         <section>
            <title>Common Conventions and Background</title>

            <para>A convention used throughout this book is to name the
            variables using all capital letters. In almost all cases,
            regardless of the shell, this is the naming convention used for
            environment variables.</para>

            <para>In all shells, an environment variable is only available
            within that single shell instance. That is, setting an environment
            variable at a command prompt only affects that specific shell and
            will not be available from other concurrent or future shells. To
            make a setting <quote>permanent</quote>, it should be done in file
            read by all shell instances when they are started. This is
            addressed briefly as appropriate for each shell type.</para>
         </section>

         <section>
            <title>Syntax Used in this Document</title>

            <para>To avoid tying this documentation to a single style of
            environment variable creation, assignment, and reference, the
            following syntax will be used exclusively from this point onward.
            Please read this carefully before proceeding.</para>

            <section>
               <title>Naming Environment Variables</title>

               <para>When naming an environment variable in the plain text of
               this document, the variable will be referred to by its name
               only. For example, to talk about the environment variable
               containing your path, we will talk about it as
               <envar>PATH</envar>.</para>
            </section>

            <section>
               <title>Creating/Setting Environment Variables</title>

               <para>The syntax to set an environment variable is:</para>

               <screen>% &lt;VARIABLE_NAME&gt; = &lt;value&gt;</screen>

               <para>Setting an environment variable also creates it if it is
               not already present in the current shell's environment.</para>
            </section>

            <section>
               <title>Printing an the Value of an Environment Variable</title>

               <para>Printing an environment variable's value to standard
               output (stdout) is done as follows:</para>

               <screen>% echo $VARIABLE_NAME
value</screen>
            </section>

            <section>
               <title>Referring to the Value of an Environment
               Variable</title>

               <para>To get the value of an environment variable when it needs
               to be expanded, the following syntax will be used:</para>

               <screen>% cd $VARIABLE_NAME/bin</screen>

               <para>Here, the reference to the value is
               <envar>$VARIABLE_NAME</envar>.</para>
            </section>
         </section>

         <section id="section.envvars.vrkit">
            <title>vrkit Environment Variables</title>

            <para>The environment variables used by vrkit are similar to the
            <quote>core</quote> environment variables used by VR
            Juggler.</para>

            <variablelist>
               <varlistentry>
                  <term>VRKIT_BASE_DIR</term>

                  <listitem>
                     <para>The environment variable
                     <envar>VRKIT_BASE_DIR</envar> identifies where vrkit is
                     installed. Important data files and plug-ins needed for
                     proper execution are searched for at run time relative to
                     the path identified by <envar>VRKIT_BASE_DIR</envar>.
                     Users generally should not need to set
                     <envar>VRKIT_BASE_DIR</envar> directly, and the remainder
                     of the description of <envar>VRKIT_BASE_DIR</envar>
                     explains when it may need to be set and when the default
                     will be more than sufficient.</para>

                     <para>The vrkit shared library determines on its own
                     where it is installed when it is attached to the
                     application process. As such, it will automatically set
                     the environment variable(s) that it needs to function
                     properly. If an environment variable is already set, then
                     its setting will <emphasis>not</emphasis> be changed by
                     the shared library when it is attached to the application
                     process.</para>

                     <tip>
                        <para>If problems occur at run time with
                        <filename>.jdef</filename> files or plug-ins failing
                        to be found, then setting
                        <envar>VRKIT_BASE_DIR</envar> will almost certainly
                        fix the problems. If the vrkit installation is
                        corrupted or non-standard (e.g., spread out across
                        several directory trees), then using
                        <envar>VRKIT_BASE_DIR</envar> in conjunction with some
                        of the environment variables described below will
                        probably prove helpful.</para>
                     </tip>

                     <para>If <envar>VRKIT_BASE_DIR</envar> needs to be set,
                     then it must be set to the base directory of the vrkit
                     installation. For example, if a UNIX version of vrkit was
                     downloaded and extracted it to the directory
                     <filename>/home/software</filename>, then
                     <envar>VRKIT_BASE_DIR</envar> would be set with this
                     command:</para>

                     <screen>% VRKIT_BASE_DIR = /home/software/vrkit</screen>

                     <para>The last component of the path may be named to
                     include the components of the vrkit version that was
                     downloaded.</para>

                     <para>If vrkit was built from the source code, the
                     compilation creates a directory called
                     <filename>instlinks</filename> which can be used as a
                     vrkit base:</para>

                     <screen>% VRKIT_BASE_DIR = $HOME/vrkit/build.linux/instlinks</screen>
                  </listitem>
               </varlistentry>

               <varlistentry>
                  <term>VRKIT_DATA_DIR</term>

                  <listitem>
                     <para>On non-<productname
                     class="registered">Windows</productname> platforms, vrkit
                     uses versioned directories to allow for parallel
                     installations of different versions. The directories that
                     are versioned are those containing the header files
                     (needed for compiling vrkit plug-ins and/or
                     applications), those containing vrkit plug-ins, and those
                     containing data files (needed for running vrkit
                     applications). In general, the value of
                     <envar>VRKIT_DATA_DIR</envar> for vrkit x.y.z ought to be
                     <filename>$VRKIT_BASE_DIR/share/vrkit-x.y.z</filename>.
                     In vrkit configuration files, there is sometimes a need
                     to refer to files in the vrkit data directories. In order
                     to allow a configuration to be used with multiple vrkit
                     versions (which may or may not be possible depending on
                     the config elements in use) or between <productname
                     class="registered">Windows</productname> and
                     non-<productname class="registered">Windows</productname>
                     platforms, users can reference the
                     <envar>VRKIT_DATA_DIR</envar> environment
                     variable.</para>

                     <para>In general, users should never have to set
                     <envar>VRKIT_DATA_DIR</envar> manually. If the
                     environment variable is not set when an application is
                     launched, it will be set automatically relative to the
                     value of <envar>VRKIT_BASE_DIR</envar>. Users should not
                     set <envar>VRKIT_DATA_DIR</envar> unless they know that
                     the default value is inappropriate.</para>
                  </listitem>
               </varlistentry>

               <varlistentry>
                  <term>VRKIT_PLUGINS_DIR</term>

                  <listitem>
                     <para>For non-<productname
                     class="registered">Windows</productname> platforms, the
                     vrkit plug-ins are stored in a versioned subdirectory of
                     <filename>$VRKIT_BASE_DIR/lib</filename> (or
                     <filename>$VRKIT_BASE_DIR/lib64</filename> on x86_64
                     architectures). Similar to <envar>VRKIT_DATA_DIR</envar>,
                     if a configuration file needs to refer to this directory,
                     it can do so by referencing the value of
                     <envar>VRKIT_PLUGINS_DIR</envar>. In general, the value
                     of <envar>VRKIT_PLUGINS_DIR</envar> for vrkit x.y.z ought
                     to be
                     <filename>$VRKIT_BASE_DIR/lib/vrkit-x.y.z/plugins</filename>
                     (or
                     <filename>$VRKIT_BASE_DIR/lib64/vrkit-x.y.z/plugins</filename>).
                     In nearly all cases, users should never have to set
                     <envar>VRKIT_PLUGINS_DIR</envar> manually. If the
                     environment variable is not set when an application is
                     launched, it will be set automatically relative to the
                     value of <envar>VRKIT_BASE_DIR</envar>. Users should not
                     set <envar>VRKIT_PLUGINS_DIR</envar> unless they know
                     that the default value is inappropriate.</para>
                  </listitem>
               </varlistentry>
            </variablelist>
         </section>
      </section>

      <section>
         <title>Acronyms</title>

         <para>Acronyms are used frequently in this document; abbreviations
         are not. In a few cases, the text switches back and forth between the
         acronym and the full spelling of the acronym. The most frequently
         used acronyms are the following:</para>

         <itemizedlist>
            <listitem>
               <para><acronym>DLL</acronym>: Dynamically loadable
               library</para>
            </listitem>

            <listitem>
               <para><acronym>GLSL</acronym>: The <ulink
               url="http://www.opengl.org/documentation/oglsl.html">OpenGL
               Shading Language</ulink></para>
            </listitem>

            <listitem>
               <para><acronym>GUI</acronym>: A graphical user interface</para>
            </listitem>

            <listitem>
               <para><acronym>VR</acronym>: Virtual reality</para>
            </listitem>

            <listitem>
               <para><acronym>XML</acronym>: The <ulink
               url="http://www.w3.org/XML/">eXtensible Markup
               Language</ulink></para>
            </listitem>
         </itemizedlist>
      </section>

      <section>
         <title>Typographic Conventions</title>

         <para>Typesetting conventions used in this document are as
         follows:</para>

         <itemizedlist>
            <listitem>
               <para>File names and paths appear as
               <filename>file.txt</filename></para>
            </listitem>

            <listitem>
               <para>Commands to be entered by the user appear as
               <command>command</command> or
               <command>command.exe</command></para>
            </listitem>

            <listitem>
               <para>Environment variables <emphasis>names</emphasis> appear
               as <envar>ENV_VAR</envar></para>
            </listitem>

            <listitem>
               <para>Environment variables <emphasis>values</emphasis> appear
               as <envar>$ENV_VAR</envar></para>
            </listitem>

            <listitem>
               <para>Command line options appear as <option>-o</option></para>
            </listitem>
         </itemizedlist>

         <para>In some places, command lines are wrapped to keep the text
         within the margins of a page when this document is rendered to PDF.
         Such cases should be obvious to the reader, but it is important to
         understand that the command lines are intended to appear as a single
         line when used.</para>
      </section>
   </preface>

   <chapter>
      <title>Introducing vrkit</title>

      <para>vrkit is at once many things. It is a cluster-ready, virtual
      reality (VR) application suite; it is a unique aggregation of <ulink
      url="http://www.vrjuggler.org/">VR Juggler</ulink> and <ulink
      url="http://opensg.vrsource.org/">OpenSG</ulink> that takes advantage of
      both in new and interesting ways; it is a C++ VR application development
      framework based on the notion of adding features through plug-ins; it is
      a collection of utility codeâ€•a <quote>toolbox</quote> in some senseâ€”that
      can be reused in existing VR Juggler applications. Ultimately, vrkit is
      what the user and/or application developer needs it to be. To that end,
      we introduce vrkit from different perspectives.</para>

      <section>
         <title>The User Perspective</title>

         <para>One of the most persistent shortcomings of VR Juggler in that
         it lacks powerful, ready to run applications. Source code is included
         for various example applications and test applications, but none of
         these are really suitable for users who just want to get rolling with
         VR. Traditionally, the <application>pfNav</application> application
         captured the largest feature set, but <productname>OpenGL
         Performer</productname> is not necessarily the foremost choice for
         immersive application development these days.
         <application>OpenSGNav</application> and
         <application>osgNav</application> are good starting points for people
         who want to <emphasis>write</emphasis> OpenSG- or Open Scene
         Graphâ€“based VR Juggler applications, but both are sorely lacking in
         features. For example, each can load only one model out of the box,
         and the navigation capabilities in both is nowhere near as powerful
         as what <application>pfNav</application> offers.
         <application>OpenSGNavGrab</application> and
         <application>osgNavGrab</application> at least include a primitive
         object grabbing feature, but that is the only added benefit that they
         bring to the table. None of these is truly up to snuff when it comes
         to the needs of users (non-programmers) who want feature-rich VR
         applications that are ready to run.</para>

         <para>This is where vrkit comes in. vrkit builds on VR Juggler and
         OpenSG to deliver users with a cluster-ready, powerful VR application
         suite. Out of the box, vrkit comes with a wide variety of pluggable
         features that can be combined with relative ease to meet the needs of
         typical users. Some of the more interesting features include
         automatic scene graph distribution; dynamic discovery of grabbable
         parts of models; viewpoint switching; dynamic model swapping; and
         video capture. That said, users of vrkit still have to know a thing
         or two about data, input devices, and VR in general in order to be
         able to configure and use vrkit effectively.</para>

         <para>Existing VR Juggler users are likely to be quite familiar with
         the conceptâ€”and associated frustrationâ€”of configuring VR software.
         vrkit uses the VR Juggler configuration infrastructure, though we
         will see later that it uses it in a different way. For those who
         think that VR Juggler takes more than a little effort to configure,
         be prepared because vrkit is as configurable as the authors could
         make it. It is a <emphasis>data-driven</emphasis> architecture with
         as many decisions as possible being left up to users. Because it is a
         collection of plug-ins, each of which can stand on its own,
         configuring vrkit is as easy or as hard as users choose to make it.
         Most plug-ins have built-in defaults that are used when no
         configuration is provided, but some plug-ins require configuration.
         Using default settings is rarely the way to get the best from the
         software, and users will quickly learn the benefits of understanding
         how to configure their favorite plug-ins.</para>
      </section>

      <section>
         <title>The Application Developer Perspective</title>

         <para>Application developers familiar with VR Juggler already know
         about application objects and the process of combining different
         components (device interfaces, threads, context-specific data, etc.)
         to create VR applications. At the heart of vrkit is an subclass of
         <classname>vrj::opensg::App</classname>
         (<classname>vrj::OpenSGApp</classname> for VR Juggler 2.x) called
         <classname>vrkit::Viewer</classname>, and users can derive their own
         custom subclass of <classname>vrkit::Viewer</classname>. From there,
         programmers can combine features of VR Juggler, OpenSG, and vrkit as
         necessary, but this is not the intended method for writing code based
         on vrkit.</para>

         <para>First, vrkit is a higher level interface than VR Juggler. If we
         compare VR juggler to the programming interface offered by the
         operating system, then vrkit is more akin to a GUI toolkit such as
         GTK+ or Qt. For example, instead of polling input devices every
         frame, programmers can register slots that are invoked whenever a
         signal is emitted as a result of an input event.</para>

         <para>Second, vrkit is a framework for the execution of plug-ins. We
         define plug-ins as reusable, self-contained software components.
         Plug-ins may communicate with each other through signals and slots,
         through a centralized data repository, or through some new mechanism
         devised by programmers using vrkit. It is the intention of the vrkit
         developers that programmers will primarily write plug-ins and not
         extend <classname>vrkit::Viewer</classname> through subclassing. The
         plug-ins that come with vrkit are all excellent examples of how to
         use the utility code in the core vrkit library.</para>

         <para>This brings up an important final point: the core of vrkit is
         basically utility code to be used by plug-ins. The
         <classname>vrkit::Viewer</classname> class runs the show, and we will
         see how its presence permeates throughout all code based on vrkit,
         but the rest of the vrkit core classes exist to facilitate the
         creation of powerful plug-ins. To that end, many of the classes can
         be used in other contexts to create very powerful VR applications
         quite easily.</para>
      </section>

      <section>
         <title>The Plug-in Developer Perspective</title>

         <para>The most effective way to extend vrkit is to create plug-ins.
         There are different categories of plug-ins (viewer plug-ins, object
         intersection plug-ins, object movement plug-ins, etc.), and plug-in
         programmers can always create new categories as necessary. The most
         central plug-ins are viewer plug-insâ€”those that are loaded and
         managed by the core <classname>vrkit::Viewer</classname> application
         object type. Some viewer plug-ins, such as the Grab Plug-in or the
         Mode Harness Plug-in, manage other plug-ins. By and large, there is
         no limit to the flexibility in which plug-ins can be utilized by
         vrkit. Best of all, the hard work of loading and managing plug-ins is
         done by core vrkit code that can be reused as necessary.</para>

         <para>Throughout this book, we will put a great deal of emphasis on
         plug-ins. Programmers writing plug-ins for vrkit are in the best
         position to extend and use vrkit effectively. It is quite feasible to
         develop a feature-rich immersive application composed entirely of
         plug-ins that are loaded at run time by the main vrkit application
         called <command>vrkit_app</command>.</para>

         <para>The vrkit developers encourage plug-in authors to make their
         plug-ins publicly available, either by contributing them back to be
         included with future vrkit releases or to be downloaded and added to
         existing vrkit installations. Such practices will help the vrkit
         community grow and foster a community-oriented philosophy for use and
         development. Of course, the vrkit license does not require that
         plug-ins be released under an open source license or otherwise be
         made freely available. We simply feel that the user community at
         large has much to offer and that making code available to other users
         benefits everyone involved.</para>
      </section>
   </chapter>

   <chapter id="chapter.understanding">
      <title>Understanding vrkit</title>

      <para>In order for anyone to use vrkit, it is vital to possess an
      understanding of the concepts behind vrkit. From there, we can talk
      about how to run the main vrkit application <command>vrkit_app</command>
      and its companion application <command>slaveViewer</command><indexterm>
            <primary>slaveViewer executable</primary>
         </indexterm>. Once we have a handle on application execution, then we
      can proceed to aggregating plug-ins to enable different features within
      the application.</para>

      <section>
         <title>Clustering</title>

         <para>The vrkit software combines VR Juggler and OpenSG in a way that
         has not been done beforeâ€”at least to the knowledge of the developers.
         Both VR juggler and OpenSG include clustering features. Clustering
         with VR Juggler is based on the concept of input device sharing.
         Every node of the cluster (typically) runs identical application
         code, and thus if they all receive the same input, they will produce
         the same output. By synchronizing the rendering, the result is a
         consistent view of the virtual world on all the nodes of the
         cluster.</para>

         <para>OpenSG clustering is based on scene graph sharing. The idea
         here is that the data is loaded on one node of the cluster and
         distributed to all the others via the network. This node is the one
         that has any and all input devices connected to it because it is the
         only one that is allowed to modify the scene graph. Changes to the
         scene on the main node (the client in OpenSG terms) are propagated
         each frame to the render nodes (the servers). Thus, the scene state
         remains consistent and coherent across the nodes of the cluster.
         Clustered OpenSG applications are therefore two different
         applications: the client that loads and distributes the data and the
         server(s) that receive and render the data.</para>

         <para>With vrkit, we have combined these two clustering techniques.
         On the main node of the cluster (the master), we run the application
         that loads all the plug-ins and all the data that defines the
         immersive space. All input devices must be connected to this node
         because it is the one and only node that is responsible for
         distributing input device data across the cluster via VR Juggler
         clustering. The other nodes of the cluster (the slaves) run a very
         simple application that loads no plug-ins and simply receives the
         scene graph data via OpenSG clustering and renders the scene using
         the appropriate viewing volume.</para>
      </section>

      <section>
         <title>Application Execution</title>

         <para>vrkit always has one main application that does the bulk of the
         work. Generally, this is referred to as the master or the viewer.
         This application loads the necessary plug-ins and loads the scene
         graph data from disk. The standard vrkit master application is called
         <command>vrkit_app</command>. It is suitable for anyone wishing to
         use vrkit exclusively through plug-in aggregation.</para>

         <para>In a cluster scenario, the master application communicates with
         another application called the slave application. The job of the
         slave application is to render the scene graph received over the
         network. In nearly all cases, the standard vrkit slave application
         called <command>slaveViewer</command><indexterm>
               <primary>slaveViewer executable</primary>
            </indexterm> can be used for this purpose<footnote>
               <para>The only time when <command>slaveViewer</command> by
               itself is not sufficient is when an application has been
               written that extends the vrkit cluster communication protocol.
               This is a rather advanced topic that is beyond the scope of
               this book. Refer instead to the vrkit <emphasis>Programmer's
               Guide</emphasis> for more information.</para>
            </footnote>. Each slave viewer application connects to the waiting
         master application, and once all have connected, the initial scene
         graph is delivered. All scene graph updates from that point on are
         distributed from the master to the slaves each frame.</para>

         <para>For the purposes of this documentation, we will focus on the
         use of <command>vrkit_app</command> and
         <command>slaveViewer</command>. We expect that alternatives to these
         will operate similarly, but that is up to the application authors to
         decide and document for themselves.</para>

         <important>
            <para>Thus far, <command>vrkit_app</command> has had no way to
            <emphasis>configure</emphasis> the application unit of measure. It
            uses the VR Juggler default of feet. Users can change the
            application code in the usual VR Juggler way to use a different
            unit of measure, but making this configurable would be preferable.
            A future version of <command>vrkit_app</command> will include this
            capability.</para>
         </important>

         <section>
            <title>Application Command Line Arguments</title>

            <para>Both <command>vrkit_app</command> and
            <command>slaveViewer</command><indexterm>
                  <primary>slaveViewer executable</primary>
               </indexterm> have their own set of command line arguments. We
            address each below. Depending on the version of VR Juggler being
            used, the command line options will vary, and we address that
            detail as appropriate. Readers who are not familiar with general
            VR Juggler application execution should refer to the VR Juggler
            <emphasis>Getting Started Guide</emphasis> before proceeding
            further.</para>

            <section>
               <title><command>vrkit_app</command> Options</title>

               <indexterm class="startofrange"
                          id="index.vrkit_app.app.options">
                  <primary>vrkit_app executable</primary>

                  <secondary>command line options</secondary>
               </indexterm>

               <para>The <command>vrkit_app</command> executable accepts a
               number of command line options. The usage can be displayed by
               running the application with the
               <option>-h</option>/<option>--help</option> option. It is
               important to understand that every option has a long form
               (e.g., <option>--help</option>) and a short form
               (<option>-h</option>). Using the long form of a command line
               option that takes an argument requires special syntax. The
               difference is shown in the following two equivalent command
               lines:</para>

               <screen>% vrkit_app -a navgrab.jconf -j standalone.jconf
% vrkit_app --app=navgrab.jconf --jconf=standalone.jconf</screen>

               <para>With that, we now present the command line options
               accepted by <command>vrkit_app</command>:</para>

               <variablelist>
                  <varlistentry>
                     <term>-j/--jconf</term>

                     <listitem>
                        <para>Provide the path to a VR Juggler configuration
                        file. One or more files can be named by using multiple
                        instances of this parameter. At least one file is
                        required. This can be an absolute path, a relative
                        path, or simply the name of a
                        <filename>.jconf</filename> file that can be found
                        using the configuration file search path. All config
                        elements contained in the named file must be for
                        Juggler components or other code units that use
                        run-time reconfiguration. Those that are not will end
                        up in the pending list.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-a/--app</term>

                     <listitem>
                        <para>Provide the path to a vrkit configuration file.
                        One or more files can be named by using multiple
                        instances of this parameter. At least one file is
                        required. This can be an absolute or a relative path
                        to a <filename>.jconf</filename> file. The
                        configuration file search path is
                        <emphasis>not</emphasis> used to find this file. All
                        config elements contained in the named file must be
                        for vrkit components. The handling of the config
                        elements depends on what plug-ins are loaded, but in
                        general, each component will look for one element
                        matching its desired type. For example, if a vrkit
                        configuration contains multiple
                        <sgmltag>vrkit_viewer</sgmltag> config elements, only
                        one will be used.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-d/--defs</term>

                     <listitem>
                        <para>Extend the config definition file search path to
                        include a named directory. One or more directories
                        containing config definition files (XML files named
                        with the extension <filename>.jdef</filename>) can be
                        specified by using multiple instances of this
                        parameter. By default,
                        <filename>$VRKIT_DATA_DIR/definitions</filename> is
                        added to the config definition search path if no
                        instance of this parameter is passed on the command
                        line. This is an alternative to using the
                        <envar>JCCL_DEFINITION_PATH</envar> environment
                        variable, but <envar>JCCL_DEFINITION_PATH</envar> will
                        always be used if it is set.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-f/--file</term>

                     <listitem>
                        <para>Name a model file for OpenSG to load. This
                        argument is optional. In general, it is probably
                        better to use the Model Loader Plug-in<indexterm>
                              <primary>plug-ins</primary>

                              <secondary>viewer</secondary>

                              <tertiary>Model Loader</tertiary>
                           </indexterm> to load models than this option, of
                        which only one instance is allowed on the command
                        line. When used with the right vrkit configuration,
                        however, this option can be quite handy for a quick
                        fly-through of a model and/or dynamic discovery of
                        grabbable components.</para>
                     </listitem>
                  </varlistentry>
               </variablelist>

               <para>If VR Juggler 2.3 or newer is being used, the additional
               option <option>--vrjmaster</option> for identifying the
               application as being on the master cluster node is also
               available.</para>

               <important>
                  <para>The following example uses of
                  <command>vrkit_app</command> are designed to illustrate
                  concepts rather than to be models of how to use
                  <command>vrkit_app</command>. First and foremost, most users
                  will probably not be running vrkit applications from within
                  the vrkit source tree. Second, users doing more with vrkit
                  than tinkering around will not be interested in loading the
                  default scene
                  <filename>data/scenes/test_scene.osb</filename>. Instead,
                  the Model Loader Plug-in<indexterm>
                        <primary>plug-ins</primary>

                        <secondary>viewer</secondary>

                        <tertiary>Model Loader</tertiary>
                     </indexterm> should be used for loading models.</para>
               </important>

               <para>A typical way of using <command>vrkit_app</command> is
               the following, executed from the root directory of the vrkit
               source tree:</para>

               <screen>% build.linux/instlinks/bin/vrkit_app -a src/Viewer/navgrab.jconf
                                      -j standalone.jconf</screen>

               <para>The above command runs with a vrkit configuration that
               supports mode switching, navigation, grabbing, and video
               capture (as of this writing). However, no model is loaded, so
               there will be nothing to grab. To load a single model at the
               world origin, use the
               <option>-f</option>/<option>--file</option> option. To load
               mutiple models that can be transformed individually, configure
               and use the Model Loader Plug-in<indexterm>
                     <primary>plug-ins</primary>

                     <secondary>viewer</secondary>

                     <tertiary>Model Loader</tertiary>
                  </indexterm> (see <xref
               linkend="section.vrkit.plugins.model.loader" />) and/or the
               Model Swap Plug-in<indexterm>
                     <primary>plug-ins</primary>

                     <secondary>viewer</secondary>

                     <tertiary>Model Swap</tertiary>
                  </indexterm> (see <xref
               linkend="section.vrkit.plugins.model.swap" />). An example
               model is provided in the file
               <filename>$VRKIT_DATA_DIR/data/scenes/test_model.osb</filename>.
               The VR Juggler configuration
               <filename>standalone.jconf</filename> is used and found
               relative to the configuration file search path.</para>

               <para>If <command>vrkit_app</command> is being run in a cluster
               configuration, a common usage would be similar to the
               following:</para>

               <screen>% build.linux/instlinks/bin/vrkit_app -a src/Viewer/navgrab.jconf
                                      -a src/Viewer/cluster.mixin.jconf
                                      -j /path/to/site-cluster.jconf</screen>

               <para>In this example, we have added vrkit cluster
               configuration information in the "mix-in" file
               <filename>src/Viewer/cluster.mixin.jconf</filename>. The
               critical piece of information for vrkit's cluster configuration
               is the number of slave nodes that will be connecting.</para>

               <para>The form of the above example for VR Juggler 2.3 and
               newer is as follows:</para>

               <screen>% build.linux/instlinks/bin/vrkit_app -a src/Viewer/navgrab.jconf
                                      -a src/Viewer/cluster.mixin.jconf
                                      -j /path/to/site-cluster.jconf
                                      --vrjmaster</screen>

               <caution>
                  <para>It is very important not to mix up
                  <filename>.jconf</filename> files used for configuration VR
                  Juggler with those for configuring vrkit. The contained
                  config elements will not be handled correctly unless the
                  file contents are identified with the correct command line
                  options.</para>
               </caution>

               <indexterm class="endofrange"
                          startref="index.vrkit_app.app.options"></indexterm>
            </section>

            <section>
               <title><command>slaveViewer</command> Options</title>

               <indexterm class="startofrange"
                          id="index.slaveViewer.app.options">
                  <primary>slaveViewer executable</primary>

                  <secondary>command line options</secondary>
               </indexterm>

               <para>The <command>slaveViewer</command> executable accepts a
               number of command line options. The usage can be displayed by
               running the application with the
               <option>-h</option>/<option>--help</option> option. As with
               <command>vrkit_app</command>, it is important to understand
               that every option has a long form (e.g.,
               <option>--help</option>) and a short form
               (<option>-h</option>), and the usage syntax of the long form
               and the short form is the same as with
               <command>vrkit_app</command>. The command line options accepted
               by <command>slaveViewer</command> are the following:</para>

               <variablelist>
                  <varlistentry>
                     <term>-j/--jconf</term>

                     <listitem>
                        <para>Provide the path to a VR Juggler configuration
                        file. One or more files can be named by using multiple
                        instances of this parameter. At least one file is
                        required when using a version of VR Juggler older than
                        2.3.0. For VR Juggler 2.3 and beyond, this option is
                        not available. The parameter value can be an absolute
                        path, a relative path, or simply the name of a
                        <filename>.jconf</filename> file that can be found
                        using the configuration file search path. All config
                        elements contained in the named file must be for
                        Juggler components or other code units that use
                        run-time reconfiguration. Those that are not will end
                        up in the pending list. For versions of VR Juggler
                        prior to 2.3, this will almost always be the same
                        file(s) that are passed to the master
                        application.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-a/--addr</term>

                     <listitem>
                        <para>Give the IP address or host name and port number
                        for the master application in the form
                        <literal>address:port</literal>. This option is
                        required. The values used here depend on how the
                        master application cluster component is configured
                        (see above). Do not confuse this option with the
                        <option>-a</option>/<option>--app</option> option used
                        by <command>vrkit_app</command>. For the slave
                        application, we provide no vrkit config elements
                        whatsoever.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-r/--root</term>

                     <listitem>
                        <para>Name the root node of the scene graph being
                        shared by the master. Again, the name of this depends
                        on how the master application cluster component is
                        configured, but this will most likely have the value
                        <quote>RootNode</quote>, which happens to be the
                        default if this parameter is not given on the command
                        line.</para>
                     </listitem>
                  </varlistentry>

                  <varlistentry>
                     <term>-m/--mask</term>

                     <listitem>
                        <para>The value of the render action traversal mask in
                        base-8, base-10, or base-16 notation. This is only
                        required when the master application is using a custom
                        traversal mask. In that event, the slave viewer must
                        use the same traversal mask in order to get proper
                        rendering behavior. The default value is
                        <literal>0xfffffffff</literal>, the same as the
                        <classname>vrkit::Viewer</classname> class
                        default.</para>
                     </listitem>
                  </varlistentry>
               </variablelist>

               <para>If VR Juggler 2.3 or newer is being used, the additional
               option <option>--vrjslave</option> for identifying the
               application as being on the slave cluster node must be
               used.</para>

               <para>An example of using this application with VR Juggler 2.2
               (or 2.0) is the following:</para>

               <screen>% slaveViewer -j /path/to/site-cluster.jconf -a master:34000</screen>

               <para>This assumes that the name of the master cluster node is
               <quote>master</quote> and that it is listening on port 34000
               for incoming vrkit slave application connections.</para>

               <para>The form of the above example for VR Juggler 2.3 and
               newer is as follows:</para>

               <screen>% slaveViewer --vrjslave -a master:34000</screen>

               <indexterm class="endofrange"
                          startref="index.slaveViewer.app.options"></indexterm>
            </section>
         </section>

         <section>
            <title>Application Configuration: VR Juggler</title>

            <para>Both the master and the slave applications are VR Juggler
            applications, and thus they require configuration information in
            order to open windows, receive input, etc. Existing VR juggler
            configuration files, either examples from the VR Juggler
            distribution or site-specific configurations, can be used with
            vrkit applications. These files are identified using the
            <option>-j</option>/<option>--jconf</option> command line
            option.</para>
         </section>

         <section>
            <title>Application Configuration: vrkit Master</title>

            <para>The vrkit master application uses VR Juggler configuration
            files (XML files ending with the extension
            <filename>.jconf</filename> that contain <quote>config
            elements</quote>), but it does not use the VR Juggler run-time
            reconfiguration feature. Instead, vrkit components are all
            configured statically when the application is initialized. This is
            a design limitation of vrkit since run-time reconfiguration is a
            very powerful and unique feature of VR Juggler. However, the
            decision was made very early on to keep the configuration of vrkit
            simple, and the use of run-time reconfiguration was considered
            unnecessary. That may change in the future.</para>

            <para>There are several example application configurations
            provided with vrkit. These can be used as the starting point for
            more complex vrkit application configurations. They are as
            follows:</para>

            <itemizedlist>
               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/flythrough.jconf</filename>:
                  A very simple configuation that allows for flythrough of a
                  scene. The loading of a model is not defined by this
                  configuration, but the vrkit_app
                  <option>-f</option>/<option>--file</option> option can be
                  used to load a single model. Otherwise, the Model Loader
                  Plug-in<indexterm>
                        <primary>plug-ins</primary>

                        <secondary>viewer</secondary>

                        <tertiary>Model Loader</tertiary>
                     </indexterm> and/or the Model Swap Plug-in<indexterm>
                        <primary>plug-ins</primary>

                        <secondary>viewer</secondary>

                        <tertiary>Model Swap</tertiary>
                     </indexterm> can be used to load multiple models.</para>
               </listitem>

               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/nav-viewpoint.jconf</filename>:
                  A somewhat more advanced flythrough configuration that
                  enables viewpoint switching. The viewpoints are defined by
                  configuration of the Viewpoints Plug-in<indexterm>
                        <primary>plug-ins</primary>

                        <secondary>viewer</secondary>

                        <tertiary>Viewpoints</tertiary>
                     </indexterm>.</para>
               </listitem>

               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/navgrab.jconf</filename>:
                  An even more advanced flythrough configuration that also
                  includes object grabbing capabilities, viewpoint switching,
                  and video capture. Dynamic discovery of grabbable components
                  is enabled by default, although only OpenSG scene graph
                  nodes with a Transform core type are identified as being
                  grabbable. This can be changed by extending the list of core
                  types of interest.</para>
               </listitem>

               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/viewer-model-loader.jconf</filename>:
                  A simple configuration that demonstrates how to configure
                  the Model Loader Plug-in to load and transform multiple
                  models to create a scene.</para>
               </listitem>

               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/viewer-model-swap.jconf</filename>:</para>
               </listitem>

               <listitem>
                  <para><filename>$VRKIT_DATA_DIR/apps/Viewer/cluster.mixin.jconf</filename>:
                  A mix-in configuration that sets up the cluster-specific
                  aspects of vrkit. This can be combined with any other vrkit
                  application configuration to enable clustering.</para>
               </listitem>
            </itemizedlist>

            <para>In general, these configurations are intended for use with
            <command>vrkit_app</command>, but they all configure components of
            vrkit that are available to any vrkit application.</para>
         </section>
      </section>
   </chapter>

   <chapter id="chapter.core.components">
      <title>vrkit Core Components</title>

      <indexterm class="startofrange" id="index.config.vrkit">
         <primary>configuration</primary>

         <secondary>vrkit</secondary>
      </indexterm>

      <para>Most vrkit applications will make use of core vrkit components. In
      this chapter, we explain how to configure those components of vrkit that
      are not related to cluster execution. Clustering is handled as a
      separate configuration topic later in <xref
      linkend="section.app.specific.config.cluster" />.</para>

      <section id="section.digital.commands">
         <title>Digital Commands</title>

         <indexterm class="startofrange" id="index.digital.command.language">
            <primary>digital command</primary>
         </indexterm>

         <indexterm>
            <primary>vrkit</primary>

            <secondary>digital command</secondary>

            <see>digital command</see>
         </indexterm>

         <para>In the cases where multiple digital inputs can be composed to
         cause an action to be performed, a special-purpose language is
         supported by vrkit. Arbitrarily complex boolean expressions can be
         used to describe the active state of what is called a
         <firstterm>digital command</firstterm>. In config elements used by
         vrkit components, the use of digital commands is usually indicated by
         a property whose value represents a <firstterm>digital command
         expression</firstterm><indexterm>
               <primary>digital command expression</primary>
            </indexterm>â€”one of the aforementioned boolean expressions.</para>

         <para>The fundamental part of a digital command expression is a
         <firstterm>digital button state</firstterm><indexterm>
               <primary>digital button state</primary>
            </indexterm>. Buttons are identified using an integer value
         greater than or equal to 0 and less than the number of digital
         buttons configured for the vrkit wand interface<indexterm>
               <primary>wand interface</primary>
            </indexterm> (see <xref
         linkend="section.config.vrkit.wand.interface" />). A digital button
         can be in one of four states: off, on, toggled on since the last
         frame, or toggled off since the last frame. These states are
         represented syntactically using the modifier characters
         <literal>-</literal>, <literal>+</literal>, <literal>^</literal>, and
         <literal>v</literal><indexterm>
               <primary>digital command</primary>

               <secondary>button state operators</secondary>
            </indexterm> respectively. This is illustrated in the following
         examples of digital button states:</para>

         <itemizedlist>
            <listitem>
               <para><literal>0-</literal>: Button 0 is in the
               <quote>off</quote> state</para>
            </listitem>

            <listitem>
               <para><literal>1+</literal>: Button 1 is in the
               <quote>on</quote> state</para>
            </listitem>

            <listitem>
               <para><literal>2^</literal>: Button 2 is in the <quote>toggled
               on</quote> state (it has been pressed since the previous
               frame)</para>
            </listitem>

            <listitem>
               <para><literal>2v</literal>: Button 2 is in the <quote>toggled
               off</quote> state (it has been released since the previous
               frame)</para>
            </listitem>
         </itemizedlist>

         <para>One or more digital button states are combined in boolean
         expressions that describe the active state for the digital command.
         The available operations are AND, INCLUSIVE OR, EXCLUSIVE OR, and
         NEGATION. These are represented by the operator symbols
         <literal>&amp;</literal>, <literal>|</literal>, <literal>^</literal>,
         and <literal>!</literal><indexterm>
               <primary>digital command</primary>

               <secondary>expression operators</secondary>
            </indexterm> respectively. The first three are binary operators,
         meaning that they operate on two digital button states. The last is a
         unary operator, meaning that it negates the state of the expression
         that follows it. Parentheses provide a grouping operation around any
         expression, thus completing the support for arbitrarily complex
         expressions. Consider the following examples:</para>

         <itemizedlist>
            <listitem>
               <para><literal>0-</literal>: Button 0 in the off state</para>
            </listitem>

            <listitem>
               <para><literal>1+</literal>: Button 1 in the on state</para>
            </listitem>

            <listitem>
               <para><literal>0^ | 2^</literal>: Buttons 0 and 2 are in the
               toggled on state</para>
            </listitem>

            <listitem>
               <para><literal>!3+</literal>: Button 3 is not in the on
               state</para>
            </listitem>

            <listitem>
               <para><literal>(1v | 2v) &amp; 3+</literal>: Buttons 1 or 2 are
               in the toggled off state while button 3 is in the on
               state</para>
            </listitem>

            <listitem>
               <para><literal>0- &amp; !(1+ | 2+)</literal>: Button 0 is in
               the off state and neither button 1 nor button 2 is in the on
               state</para>
            </listitem>

            <listitem>
               <para><literal>3^ ^ 7^</literal>: Button 3 or button 7 is in
               the toggled on state but not both</para>
            </listitem>
         </itemizedlist>

         <para>Note that the first two examples in the preceding list are the
         same as the first two examples in the list of digital button states.
         The state of a single button represents a boolean expression just as
         does a very complex combination of button states. An empty expression
         (a zero-length string) indicates that the action will be
         disabled.</para>

         <indexterm class="endofrange"
                    startref="index.digital.command.language"></indexterm>
      </section>

      <section id="section.config.vrkit.viewer">
         <title>Viewer</title>

         <indexterm class="startofrange" id="index.config.vrkit.viewer">
            <primary>configuration</primary>

            <secondary>viewer</secondary>
         </indexterm>

         <para>The core of vrkit is the viewer class. It is configured using a
         config element of type <literal>vrkit_viewer</literal>. All vrkit
         application configurations are likely to need one such config
         element. The first configurable property is the symbolic name of the
         scene graph root. This name is what the slave viewer application
         searches for in the shared scene graph data received when it first
         connects to the master cluster node. The default value is
         <quote>RootNode,</quote> and it should be configured to use the
         default value. By default, the slave viewer expects the root of the
         shared scene graph to be named <quote>RootNode.</quote> If the root
         node name is changed, then the batch file used to launch
         <command>slaveViewer</command><indexterm>
               <primary>slaveViewer executable</primary>
            </indexterm> must be updated to add the
         <option>-r</option>/<option>--root</option> option with the new root
         node name.</para>

         <para>The next configurable property is the plug-in search path,
         which is a list of directory names. By default, the base vrkit viewer
         application searches in <envar>VRKIT_PLUGINS_DIR</envar> for plug-ins
         to be loaded at run time. The search path is extended using this
         property. The directories named in the plug-in search path can
         contain environment variables and must use the syntax
         <literal>${ENV_VAR}</literal>.</para>

         <para>Next, we must identify the base set of viewer plug-ins that
         will be loaded by the application. The choice of viewer plug-ins is
         entirely dependent upon the desired functionality (i.e., the feature
         set) of the application. The plug-ins and their respective
         configuration details are addressed in <xref
         linkend="chapter.plugins" />.</para>

         <para>The last configurable property of this config element is the
         object <firstterm>intersection strategy</firstterm> to use. The
         intersection strategy determines what vrkit intersection strategy
         plug-in will be used to perform intersection with objects in the
         virtual world. There are two choices currently available: <quote>Ray
         Intersection</quote><indexterm>
               <primary>plug-ins</primary>

               <secondary>intersection strategy</secondary>

               <tertiary>Ray Intersection</tertiary>
            </indexterm> and <quote>Point Intersection<indexterm>
               <primary>plug-ins</primary>

               <secondary>intersection strategy</secondary>

               <tertiary>Point Intersection</tertiary>
            </indexterm>.</quote> The former uses ray-based intersection tests
         where a ray is shot out from the wand, and intersection tests are
         performed with the bounding volumes of objects. The latter requires
         that the wand be positioned so that it directly intersects with the
         object. Configuration of the grabbing and movement of objects is
         explained later in <xref linkend="section.vrkit.plugins.grab" />, but
         be aware that the choice of the intersection strategy will influence
         the user's ability to grab objects.</para>

         <indexterm class="endofrange" startref="index.config.vrkit.viewer"></indexterm>
      </section>

      <section id="section.app.specific.config.cluster">
         <title>Cluster</title>

         <indexterm class="startofrange" id="index.config.vrkit.cluster">
            <primary>configuration</primary>

            <secondary>cluster</secondary>
         </indexterm>

         <para>The cluster configuration of the vrkit viewer application class
         is separated from the core vrkit viewer configuration. This is done
         so that the cluster configuration can be <quote>mixed in</quote> when
         necessary. Remember that <command>vrkit_app</command> accepts
         multiple <option>-a</option>/<option>--app</option> command line
         options, thus allowing the vrkit-specific config elements to be
         combined in different ways.</para>

         <para>The vrkit cluster-specific details are wholly separate from the
         VR Juggler cluster configuration details. The config element used to
         configure the vrkit cluster features is of type
         <literal>vrkit_cluster</literal>. It provides the heart of the
         cluster-specific configuration. The first property of this config
         element indicates the IP address to which the listening socket will
         be bound. This is only necessary for multi-homed computers when it is
         important to bind to specific IP address so that the user of the
         remote GUI knows how to connect to the immersive application. If this
         property has no value, the software automatically binds to the first
         non-loopback IP address of the computer. If there is no non-loopback
         address, then the software binds to the loopback address
         (127.0.0.1).</para>

         <para>The next property is the integer port number on which the
         master node will listen for incoming connections must be configured
         to a value between 1000 and 65535. Whatever port number value is used
         here must also be identified in the batch file used to launch
         <command>slaveViewer</command><indexterm>
               <primary>slaveViewer executable</primary>
            </indexterm>. In the example vrkit cluster configuration (see
         <filename>$VRKIT_DATA_DIR/apps/Viewer/cluster.mixin.jconf</filename>),
         the port number is set to 34000 which should not interfere with any
         <productname class="registered">Microsoft Windows</productname>
         services.</para>

         <para>Up to now, we have identified two aspects of the
         <literal>vrkit_cluster</literal> config element that relate to
         clustering, but neither aspect is utilized for clustering until the
         last property in the config element is configured to a non-zero
         value. That property identifies the number of slave nodes that must
         connect to the master node before the application is fully launched.
         By default, the value for this property is 0, indicating that no
         slaves are expected and that the application should not set itself up
         to use its hybrid clustering mechanism. If, however, the value for
         this property is set to a value greater than 0, then the master node
         will wait for that many slaves to connect and initialize before the
         application frame loop is entered. If the number of slave nodes in
         use does not match the value of this property, then the application
         behavior is undefined.</para>

         <indexterm class="endofrange" startref="index.config.vrkit.cluster"></indexterm>
      </section>

      <section id="section.config.vrkit.wand.interface">
         <title>Wand Interface</title>

         <indexterm class="startofrange"
                    id="index.config.vrkit.wand.interface">
            <primary>configuration</primary>

            <secondary>vrkit</secondary>

            <tertiary>wand interface</tertiary>
         </indexterm>

         <para>In vrkit, there is a concept of a <firstterm>wand
         interface</firstterm><indexterm>
               <primary>wand interface</primary>
            </indexterm>, which is an aggregation of digital, analog, and
         positional input. This corresponds to what is traditionally called a
         <quote>wand</quote> in virtual reality system configurations. More
         abstractly, however, vrkit sees a wand interface as something that
         provides input data. It can, for example, correspond with a tracked
         <productname>Pinch</productname> Glove. In that case, the glove would
         most likely have positional information (from an affixed tracking
         sensor) and digital information (from finger combinations) but no
         analog data.</para>

         <para>The wand interface configuration defined in the example
         configurations
         <filename>$VRKIT_DATA_DIR/apps/Viewer/flythrough.jconf</filename> and
         <filename>$VRKIT_DATA_DIR/apps/Viewer/navgrab.jconf</filename> sets
         things up so that the integer identifiers 0â€“5 for digital command
         expressions<indexterm>
               <primary>digital command expression</primary>
            </indexterm> correspond to the VR Juggler proxy alias identifiers
         VJButton0, VJButton1, VJButton2, VJButton3, VJButton4, and VJButton5.
         The integer identifiers 0â€“3 for analog inputs correspond to the VR
         Juggler proxy alias identifiers VJAnalog0, VJAnalog1, VJAnalog2, and
         VJAnalog3. They are present in the desktop simulator configurations
         that come with VR Juggler. In general, the proxy aliases should be
         defined in a logical manner to correspond to digital inputs from the
         physical device. Much more information on this topic can be found in
         the <ulink
         url="http://www.infiscape.com/documentation/vrjuggler-config/2.2/configuring_vr_juggler">VR
         Juggler 2.2 <emphasis>Configuration Guide</emphasis></ulink>.</para>

         <indexterm class="endofrange"
                    startref="index.config.vrkit.wand.interface"></indexterm>
      </section>

      <section>
         <title>Basic Highlighter</title>

         <indexterm class="startofrange"
                    id="index.config.vrkit.basic.highlighter">
            <primary>configuration</primary>

            <secondary>vrkit</secondary>

            <tertiary>basic highlighter</tertiary>
         </indexterm>

         <para>When intersecting, selecting, and grabbing objects, it is
         possible to indicate their current interaction state through
         highlighting. This highlighting is all configured using the vrkit
         Basic Highlighter using a config element of type
         <literal>basic_highlighter</literal>. Highlighting is driven by
         intersection, selection, and grab events. The typical source of these
         events is the vrkit Grab Plug-in<indexterm>
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Grab</tertiary>
            </indexterm> (see <xref linkend="section.vrkit.plugins.grab" />),
         though users may choose to write their own plug-ins for this
         purpose.</para>

         <para>First, we can extend the search path used to find the remote
         highlight shader code. By default, vertex and fragment programs that
         are not named using an absolute path are searched for in the
         directory <filename>$VRKIT_DATA_DIR/data/shaders</filename>. The
         search path can be extended by listing one or more additional
         directories. The directory names in the configuration file can
         reference environment variables using the syntax
         <literal>${ENV_VAR}</literal>.</para>

         <para>Next, we can enable and disable the use of GLSL shaders for
         interaction highlighting. For the GLSL highlight shader to work, GLSL
         must be supported by the graphics card driver, and the hardware
         itself must support fragment programs and vertex programs. On
         <productname class="registered">Microsoft Windows</productname>, if
         GLSL is not supported but an attempt is made to use it, the
         application will crash. Disabling the use of the highlight shader
         enables the use of a <quote>scribing</quote> highlight that basically
         draws a wire frame outline around the object selected in the
         GUI.</para>

         <para>The next setting is the highlight color for object intersection
         events. This is configured by setting the red, green, and blue color
         components as values between 0.0 and 1.0 for each.</para>

         <para>The GLSL shader code is identified by naming the files
         containing the vertex program and the fragment program in that order.
         The file names can be relative or absolute paths. As noted
         previously, if an absolute path is used, then the shader search path
         will not be used to find the file. If one or both of the shader
         source files cannot be found or cannot be read at run time, the use
         of that shader will be disabled and the scribe highlighting effect
         will be used instead.</para>

         <para>The GLSL highlight shader code that comes with vrkit has a few
         parameters known as <firstterm>uniforms</firstterm>. These allow the
         appearance of the shader to be altered. To provide more control over
         how the highlights appear, the parameter values are specified through
         the configuration. The drawback of doing this is that the
         configuration and the C++ code managing the shader become tightly
         coupled with the shader itself, thereby placing restrictions on how a
         replacement shader would have to be written. Setting that aside, we
         have two parameters in addition to the highlight color which was
         explained above. The first is called the <quote>shader scale,</quote>
         and it defines the size of the halo effect. More specifically, the
         real-numbered value for this property causes the halo to expand that
         many units around the volume of the highlighted geometry (where the
         units are measured in millimeters). The second parameter is called
         the <quote>shader exponent,</quote> and it controls the transparency
         of the halo as it surrounds the geometry. A value of 1.0 leaves the
         transparency set as it is defined in the shader source code. A value
         greater than 1.0 results in there being more transparency in the
         middle and less at the sides when looking straight at the
         geometry.</para>

         <para>The remaining configurable properties for this component are a
         repetition of what is used for intersection events. There are
         separate settings for selecting (choosing) objects to be grabbed and
         for objects once they are grabbed. These properties can all be
         adjusted to get different highlighting behavior for these three event
         types.</para>

         <indexterm class="endofrange"
                    startref="index.config.vrkit.basic.highlighter"></indexterm>
      </section>

      <section>
         <title>Event Sound Player</title>

         <indexterm class="startofrange"
                    id="index.config.vrkit.event.sound.player">
            <primary>configuration</primary>

            <secondary>vrkit</secondary>

            <tertiary>event sound player</tertiary>
         </indexterm>

         <para>Following up on object highlighting based on intersecting,
         selecting, and grabbing objects, sounds can be played in response to
         these events. Currently, the two sounds that are supported are
         intersection and selection (grabbing). Thus, the config element for
         the vrkit Event Sound Player (type
         <literal>event_sound_player</literal>) has two configurable
         properties for these sounds. The values for the properties are sound
         aliases defined by the VR Juggler Sound Manager. If invalid or
         unknown sound identifiers are used, no sound will be played for the
         mis-configured interaction event.</para>

         <indexterm class="endofrange"
                    startref="index.config.vrkit.event.sound.player"></indexterm>

         <indexterm class="endofrange" startref="index.config.vrkit"></indexterm>
      </section>
   </chapter>

   <chapter id="chapter.plugins">
      <title>vrkit Plug-ins</title>

      <para>In this chapter, we explain the plug-ins that are distributed as
      part of the vrkit library. Configuration details are included as
      appropriate. The plug-ins are listed alphabetically by name within their
      classifying group, and readers should feel free to skip around this
      chapter reading about plug-ins as they become of interest. Any
      dependencies among these plug-ins will be noted.</para>

      <section>
         <title>Viewer Plug-ins</title>

         <indexterm class="startofrange"
                    id="index.section.vrkit.plugin.viewer">
            <primary>plug-ins</primary>

            <secondary>viewer</secondary>
         </indexterm>

         <para>We begin with those plug-ins that are classified as
         <firstterm>viewer plug-ins</firstterm>. In terms of the code, this
         means that they implement an interface
         (<classname>vrkit::viewer::Plugin</classname>) that dictates specific
         handling and behavior by other vrkit components. From a user
         perspective, these are the plug-ins that add specific visual and/or
         interactive elements to the application. There are other types of
         plug-ins, as we will see, and all of those plug-ins <quote>hang off
         of</quote> viewer plug-ins in some form or another. Thus, viewer
         plug-ins are likely to be the first that the user will
         configure.</para>

         <section id="section.vrkit.plugins.grab">
            <title>Grab Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.plugin.grab">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Grab</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.GrabPlugin</literal> or
                     <literal>GrabPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/GrabPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/GrabPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\GrabPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>vrkit_grab_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The vrkit Grab Plug-in composes functionality provided
            through dynamically loaded strategies (as in the Strategy Pattern)
            to provide object interaction capabilities to the application. The
            mechanism by which object grabbing occurs is done by a <quote>grab
            strategy</quote> (see <xref
            linkend="section.grab.strategy.plugins" />) and movement of
            grabbed objects is handled by one or more <quote>move
            strategies</quote> (to <xref
            linkend="section.move.strategy.plugins" />). The Grab Plug-in
            serves mainly to coordinate these components. We explain more
            about the grab and move strategies in later sections.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.grab">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Grab Plug-in</tertiary>
            </indexterm>

            <para>The vrkit Grab Plug-in itself is relatively complex in terms
            of its implementation, but the configuration of it (using a config
            element of type <literal>vrkit_grab_plugin</literal>) tends to
            belie that fact. The real configuration details are handled by
            several other components that are used by or are influenced by the
            vrkit Grab Plug-in. Thus, there are only two things to configure
            in this plug-in: the name of the <firstterm>grab
            strategy</firstterm> and the name of the <firstterm>move
            strategy</firstterm> (or strategies).</para>

            <para>The grab strategy is what actually responds to grab and
            release operations performed by the immersive application user.
            vrkit currently includes three grab strategy plug-ins: Single
            Object Grab<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>grab strategy</secondary>

                  <tertiary>Single Object Grab</tertiary>
               </indexterm>, Multi-Object Grab<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>grab strategy</secondary>

                  <tertiary>Multi-Object Grab</tertiary>
               </indexterm>, and Signal-Based Grab<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>grab strategy</secondary>

                  <tertiary>Signal-Based Grab</tertiary>
               </indexterm>. The Single Object Grab strategy allows users to
            grab one object at a time. See <xref
            linkend="section.vrkit.strategy.grab.single" /> for details. The
            Multi-Object Grab strategy allows users to select multiple objects
            for grabbing and then to grab them all at once. See <xref
            linkend="section.vrkit.strategy.grab.multi" /> for details.
            Finally, the Signal-Based Grab strategy offloads the decisions
            about how to grab and release objects to external code through a
            complex process of grab and release event notifications. See <xref
            linkend="section.vrkit.strategy.grab.signal" /> for
            details.</para>

            <para>The move strategy defines how grabbed objects are moved.
            Multiple move strategies are allowed to be used, and the
            application of the move behavior of each occurs in the order that
            they are listed in the configuration of the vrkit Grab Plug-in.
            Thus, it is important to list them in an order that makes sense
            mathematically. More information about the move strategies
            included with vrkit can be found in <xref
            linkend="section.move.strategy.plugins" />.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.grab"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.plugin.grab"></indexterm>
         </section>

         <section id="section.vrkit.plugins.grid">
            <title>Grid Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.grid">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Grid</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.GridPlugin</literal> or
                     <literal>GridPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/GridPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/GridPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\GridPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>vrkit_grid_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.grid"></indexterm>
         </section>

         <section id="section.vrkit.plugins.logo">
            <title>Logo Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.logo">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Logo</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.LogoPlugin</literal> or
                     <literal>LogoPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/LogoPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/LogoPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\LogoPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>logo_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.logo"></indexterm>
         </section>

         <section id="section.vrkit.plugins.materialchooser">
            <title>Material Chooser Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.materialchooser">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Material Chooser</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.MaterialChooserPlugin</literal> or
                     <literal>MaterialChooserPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/MaterialChooserPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/MaterialChooserPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\MaterialChooserPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>vrkit_material_chooser_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.materialchooser"></indexterm>
         </section>

         <section id="section.vrkit.plugins.modeharness">
            <title>Mode Harness Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.mode.harness">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Mode Harness</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.ModeHarnessPlugin</literal> or
                     <literal>ModeHarnessPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>Plug-in type: viewer</para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <para><itemizedlist>
                           <listitem>
                              <para><filename>$VRKIT_PLUGINS_DIR/ModeHarnessPlugin.so</filename></para>
                           </listitem>

                           <listitem>
                              <para><filename>$VRKIT_PLUGINS_DIR/ModeHarnessPlugin.dylib</filename></para>
                           </listitem>

                           <listitem>
                              <para><filename>%VRKIT_PLUGINS_DIR%\ModeHarnessPlugin.dll</filename></para>
                           </listitem>
                        </itemizedlist></para>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>vrkit_mode_harness_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Mode Harness handles activation and deactivation of
            dynamically loaded interactive components. This is different than
            the job performed by the vrkit Mode Switch Plug-in<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>viewer</secondary>

                  <tertiary>Mode Switch</tertiary>
               </indexterm> (see <xref
            linkend="section.vrkit.plugins.modeswitch" />) since that plug-in
            handles code that is normally associated with
            <emphasis>direct</emphasis> input handling. The components loaded
            by the Mode Harness Plug-in are mutually exclusive (only one can
            be active at a time), and they tend to define the behavior that is
            done <emphasis>in response to</emphasis> input rather than
            handling the input itself.</para>

            <para>Mode components are swapped when the application emits a
            pre-defined signal. The component that is loaded in response to
            the signal is activated, and the previous component is
            deactivated. These relationships are defined entirely through the
            configuration of this plug-in, thereby making it highly
            dynamic.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.mode.harness">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Mode Harness Plug-in</tertiary>
            </indexterm>

            <para>On the surface, configuration of this plug-in (through a
            config element of type
            <literal>vrkit_mode_harness_plugin</literal>) is simple. It
            requires three things:</para>

            <orderedlist>
               <listitem>
                  <para>A list of components</para>
               </listitem>

               <listitem>
                  <para>Identification of the default component</para>
               </listitem>

               <listitem>
                  <para>A list of signals for activating the components</para>
               </listitem>
            </orderedlist>

            <para>Configuration of the mode components handled by the Mode
            Harness Plug-in is separated into two pieces: the list of plug-ins
            that encapsulate each mode component and the list of signals that
            activate the loaded mode components. For convenience in
            <application>VRJConfig</application>, it is best to define the
            list of mode components first. The signals refer to the embedded
            mode component config elements as pointers, and thus by
            configuring the mode components first, the
            <application>VRJConfig</application> drop-down menu for each of
            the signals will be filled in completely when it comes time to
            configure them.</para>

            <para>In the <literal>plugin</literal> property for each mode
            component, fill in the component identifier. This can either be
            the unversioned name as shown in the table, or it can include the
            version by using the form
            <literal>tld.mygroup.ComponentName:major.minor.patch</literal>.
            Using the version information is optional.</para>

            <para>Next, we need to define the signals for activating the
            interaction components. These are handled by using embedded config
            elements of type <literal>mode_change_signal</literal>. As things
            are designed now, the activation signal names are built into the
            software. This makes it very important to configure this plug-in
            correctly and carefully. It also means that this plug-in cannot be
            used by a generic application such as <command>vrkit_app</command>
            without another plug-in being loaded that emits the activation and
            deactivation signals.</para>

            <para>The signals used for deactivating the current mode component
            result in activation of the default mode component. The default
            mode component is also the mode that is activated initially when
            the application starts.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.mode.harness"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.mode.harness"></indexterm>
         </section>

         <section id="section.vrkit.plugins.modeswitch">
            <title>Mode Switch Plug-In</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.mode.switch">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Mode Switch</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.ModeSwitchPlugin</literal> or
                     <literal>ModeSwitchPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>Plug-in type: viewer</para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModeSwitchPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModeSwitchPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\ModeSwitchPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>mode_switch_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>This plug-in defines the various input handling modes that
            are available in the application, the ordering of the modes, and
            what viewer plug-ins are active in which mode. The Mode Switch
            Plug-in is used most effectively to set up and manage behavior
            from plug-ins that are mutually exclusive. Two mutually exclusive
            plug-ins could not be used simultaneously, but the features of
            both may be desired from the application user. To accommodate such
            a scenario, the Mode Switch Plug-in defines a modal interaction
            behavior. At any time, only one mode is active, and only the
            plug-in(s) defined to be a part of that mode accept user input.
            This means that a given input in one mode may (and probably will)
            have a completely different interpretation in another mode.</para>

            <para>Multiple plug-ins can accept input in a single mode, and any
            given plug-in can be active in multiple modes. The most effective
            configuration for the Mode Switch Plug-in would be one that
            minimizes the mental overhead associated with keeping track of the
            current mode and all the inputs across the different modes. Since
            modal interfaces in general have higher mental overhead than
            non-modal interfaces, such a configuration would have few modes
            and few plug-ins. Use of the Status Panel Plug-in (see <xref
            linkend="section.vrkit.plugins.statuspanel" />) can help alleviate
            the mental overhead to some degree.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.mode.switch">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Mode Switch Plug-in</tertiary>
            </indexterm>

            <para>The vrkit Mode Switch Plug-in is configured using a config
            element of type <literal>mode_switch_plugin</literal>. An example
            of configuring this plug-in can be seen in
            <filename>navgrab.jconf</filename>, found in either the
            <filename>src/Viewer</filename> directory of the source tree or in
            <filename>$VRKIT_BASE_DIR/share/vrkit/apps/Viewer</filename>. The
            configuration of the Mode Switch Plug-in mainly involves listing
            all the plug-ins that will be managed and in what mode(s) each
            plug-in will be active. First, however, we must configure the
            digital command expression<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> (see <xref linkend="section.digital.commands" />)
            that causes a mode switch to occur. Since the Mode Switch Plug-in
            is active at all times, this expression should be one that is not
            used by any other plug-in. Do not use an empty value for this
            property or else mode switching will be disabled.</para>

            <para>Next, we list all the plug-ins that will be managed by the
            Mode Switch Plug-in. These must be <emphasis>viewer</emphasis>
            plug-ins that are designed to be interactive, and their
            interaction may or may not be mutually exclusive with respect to
            other interactive plug-ins. Each plug-in entry names the plug-in
            to be managed and the mode number(s) in which that plug-in will be
            active. The plug-in name uses the identifier given for each
            plug-in, a value that is set in the plug-in code. For the plug-ins
            that come with vrkit, the identifier is listed in the description
            of each in this chapter. The mode numbering is zero-based and is
            tied to the mode names that we will explain next. Configuring the
            plug-ins and their modes is complex and depends very much on the
            functionality provided by each plug-in and the input expectations
            of that plug-in.</para>

            <important>
               <para>The plug-ins that are listed in the configuration of this
               plug-in are loaded and managed by the Mode Switch Plug-in. To
               get the correct behavior, they must not also by loaded by the
               vrkit core viewer class.</para>
            </important>

            <para>Finally, we list the names of the modes. The ordering of
            this list of names must correspond to the mode numbering used for
            the plug-in list configuration. The names are simply string
            identifiers made up by the person creating the configuration. The
            configured names are displayed in the vrkit status panel.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.mode.switch"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.mode.switch"></indexterm>
         </section>

         <section id="section.vrkit.plugins.model.loader">
            <title>Model Loader Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.model.loader">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Model Loader</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.ModelLoaderPlugin</literal> or
                     <literal>ModelLoaderPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModelLoaderPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModelLoaderPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\ModelLoaderPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>model_loader_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <important>
               <para>At this time, the Model Loader Plug-in has no way to
               indicate the unit of measure for a given model or to correlate
               this with the application unit of measure. This means that
               models that are loaded must all use the same unit of measure
               which in turn must match that of the loading application. In
               the case of <command>vrkit_app</command>, all models must use
               feet as the unit of measure. This limitation will be corrected
               in a future version.</para>
            </important>

            <para>The Model Loader Plug-in can load any model format supported
            by OpenSG and apply a tranformation to it in order to position and
            rotate it as desired. The plug-in can load multiple models,
            thereby allowing the user to create an entire world from a
            collection of models.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.model.loader">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Model Loader Plug-in</tertiary>
            </indexterm>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.model.loader"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.model.loader"></indexterm>
         </section>

         <section id="section.vrkit.plugins.model.swap">
            <title>Model Swap Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.model.swap">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Model Swap</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.ModelSwapPlugin</literal> or
                     <literal>ModelSwapPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModelSwapPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ModelSwapPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\ModelSwapPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>model_swap_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <important>
               <para>At this time, the Model Swap Plug-in has no way to
               indicate the unit of measure for a given model or to correlate
               this with the application unit of measure. This means that
               models that are loaded must all use the same unit of measure
               which in turn must match that of the loading application. In
               the case of <command>vrkit_app</command>, all models must use
               feet as the unit of measure. This limitation will be corrected
               in a future version.</para>
            </important>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.model.swap"></indexterm>
         </section>

         <section id="section.vrkit.plugins.pick">
            <title>Pick Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.pick">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Pick</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.PickPlugin</literal> or
                     <literal>PickPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/PickPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/PickPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\PickPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>pick_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.pick"></indexterm>
         </section>

         <section id="section.vrkit.plugins.viewer.simplenav">
            <title>Simple Navigation Plug-In</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.simple.nav">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Simple Navigation</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.SimpleNavPlugin</literal> or
                     <literal>SimpleNavPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/SimpleNavPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/SimpleNavPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\SimpleNavPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>simple_nav_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Simple Navigation Plug-in is a rudimentary
            implementation of wand-based navigation. Users can move forward,
            move backward, and rotate at a constant, hard-coded velocity.
            There are two navigation modes, walk and fly, between which the
            user can toggle. Generally, there should be no need to use this
            plug-in, though its simplistic navigation does have its place when
            features such as acceleration and braking are deemed too
            complicated for users.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.viewer.simplenav">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Simple Navigation Plug-in</tertiary>
            </indexterm>

            <para>The configurable properties are limited to the digital
            command expressions<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> (see <xref linkend="section.digital.commands" />)
            used to perform the aforementioned actions. In each case, a
            digital command expression is used to describe the active state
            for the action. An empty value means that the action will be
            disabled.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.viewer.simplenav"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.wand.nav"></indexterm>
         </section>

         <section id="section.vrkit.plugins.statuspanel">
            <title>Status Panel Plug-In</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.status.panel">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Status Panel</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.StatusPanelPlugin</literal> or
                     <literal>StatusPanelPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/StatusPanelPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/StatusPanelPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\StatusPanelPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>status_panel_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The job of the Status Panel Plug-in is to add the vrkit
            status panel to the scene. The vrkit status panel is a pre-defined
            component of the vrkit library that displays text in one of three
            sub-panels. The application programmer targets a given piece of
            text information to one of the three sub-panels depending on the
            meaning of the text. Behind the scenes in the vrkit library, the
            status panel is always available for use, but it is not displayed
            in the scene unless the Status Panel Plug-in is loaded.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.status.panel">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>status panel</tertiary>
            </indexterm>

            <para>The vrkit library has a status panel provided through the
            Status Panel Plug-in<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>vrkit</secondary>

                  <tertiary>Status Panel</tertiary>
               </indexterm>. The status panel displays information about what
            is currently happening in the virtual space. In the case of the
            <command>vrkit_app</command> application, it shows the current
            mode, the digital expressions<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> to invoke specific actions within that mode, and
            various status messages about the execution of the software. We
            will see that configuring the vrkit status panel, using a config
            element of type <literal>status_panel_plugin</literal>, is quite
            easy.</para>

            <para>The first aspect of configuring the vrkit status panel is
            the digital command expression to invoke the grab operation. In
            certain use cases, the vrkit status panel can be grabbed,
            repositioned and resized, but this capability is not current
            implemented. As such, we will not address configuring the digital
            command expression for grabbing the status panel. The value of
            this property must be an empty string.</para>

            <para>Instead, the first property of the vrkit status panel that
            we will address is the size of the status panel. The size is
            defined by the real-numbered width and height of the panel
            measured in <emphasis>feet</emphasis>. While most aspects of
            configuring software based on VR Juggler are configured using
            meters, this custom piece implemented in vrkit is configured using
            feet. The idea is that vrkit is being used primarily by people
            whose immersive visualization installations are measured in feet,
            and as such, using feet to define the dimensions of the status
            panel makes sense.</para>

            <para>Next, we have the position of the status panel. This is also
            measured in feet and is defined using three real-numbered values
            for the X, Y, and Z position of the lower left corner of the
            panel. Positioning the status panel depends on the preferences of
            the application user. By placing the status panel on the plane of
            an immersive system projection surface, it will appear to be
            positioned statically regardless of where the user is within the
            scene. Another likely position for the status panel is to place it
            slightly behind a projection surface. Doing so can help keep it
            out of the main focus of the user's eyes except when s/he wants to
            concentrate on it.</para>

            <para>Finally, the rotation of the status panel can be configured.
            The panel rotation is defined as rotations about the X, Y, and Z
            axes in degrees.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.status.panel"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.status.panel"></indexterm>
         </section>

         <section id="section.vrkit.plugins.video.capture">
            <title>Video Capture Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.video.capture">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Video Capture</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.VideoCapturePlugin</literal> or
                     <literal>VideoCapturePlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/VideoCapturePlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/VideoCapturePlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\VideoCapturePlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>vrkit_video_capture_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.video.capture"></indexterm>
         </section>

         <section id="section.vrkit.plugins.viewpoint">
            <title>Viewpoints Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.viewpoints">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Viewpoints</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.ViewpointsPlugin</literal> or
                     <literal>ViewpointsPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ViewpointsPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/ViewpointsPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\ViewpointsPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>viewpoints_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.viewpoints"></indexterm>
         </section>

         <section id="section.vrkit.plugins.volume.drawing">
            <title>Volume Drawing Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.volume.drawing">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Volume Drawing</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.VolumeDrawingPlugin</literal> or
                     <literal>VolumeDrawingPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/VolumeDrawingPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/VolumeDrawingPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\VolumeDrawingPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>This is a very simple plug-in that enables rendering of
            OpenSG volumes for all scene graph objects. There is nothing to
            configure. Using it is sufficient to activate the rendering of the
            volumes. As a viewer plug-in, it can be one of the plug-ins
            managed by the Mode Switch Plug-in<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>vrkit</secondary>

                  <tertiary>Mode Switch</tertiary>
               </indexterm> (see <xref
            linkend="section.vrkit.plugins.modeswitch" />), thereby allowing
            creation of a mode that be activated to display the scene graph
            object bounding volumes.</para>

            <sidebar>
               <para>If nothing else, this little plug-in demonstrates a
               critical concept of vrkit. Namely, useful behavior can be
               captured in a reusable component, large or small, that can be
               utilized in different ways depending on the software
               configuration. Getting used to this way of doing things will
               help users of vrkit take full advantage of what this software
               offers.</para>
            </sidebar>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.volume.drawing"></indexterm>
         </section>

         <section id="section.vrkit.plugins.wandnav">
            <title>Wand Navigation Plug-In</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.wand.nav">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Wand Navigation</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.WandNavPlugin</literal> or
                     <literal>WandNavPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/WandNavPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/WandNavPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\WandNavPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>wand_nav_plugin</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Wand Navigation Plug-in is a much more advanced
            navigation plug-in than the Simple Navigation Plug-in<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>viewer</secondary>

                  <tertiary>Simple Navigation</tertiary>
               </indexterm>, but with these more advanced capabilities come
            more complexity in the plug-in configuration. In the case of this
            plug-in, the acceleration factor and the maximum velocity can be
            configured. The units for these settings are based on the
            application unit of measure (feet for
            <command>vrkit_app</command>). Further, the button settings are
            fully configurable, and multiple buttons can be used to invoke an
            action, and any of the actions can be disabled through the
            configuration. There are five actions available for use: positive
            acceleration, negative acceleration, rotation, navigation mode
            switching (between walk and fly), and navigation resetting.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.plugin.wand.nav">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Wand Navigation Plug-in</tertiary>
            </indexterm>

            <para>There are several properties in the configuration of this
            plug-in (using a config element of type
            <literal>wand_nav_plugin</literal>), the first group of which
            define physical attributes of the navigation behavior. The maximum
            allowed velocity, the positive acceleration factor, the negative
            acceleration (deceleration) factor, and the rotational sensitivity
            can all be adjusted here. The maximum velocity is measured in
            application units (U) per second (U/s), and the acceleration
            factors are measured in U/s<superscript>2</superscript>. The
            rotational sensitivity is used as a multiplier on the frame time
            when computing how far to rotate. The higher the value, the faster
            the rotation will be.</para>

            <para>Next, we have the digital command expressions<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> for the plug-in. There are five actions that can
            be performed by this plug-in: positive acceleration, negative
            acceleration, rotation, navigation mode switching, and navigation
            resetting. In each case, a digital command expression is used to
            describe the active state for the action. An empty value means
            that the action will be disabled. See <xref
            linkend="section.digital.commands" /> for more details on digital
            commands and digital command expressions.</para>

            <para>The manner in which the actions are configured should
            normally be done in a way that makes senese. For example, positive
            acceleration ought to require that the configured button(s) be
            pressed continually (using the <literal>+</literal> modifier).
            When released, the velocity will go to zero. Navigation mode
            switching, on the other hand, should only happen when the
            configured button(s) is (are) toggled from the off state to the on
            state (using the <literal>^</literal> modifier).</para>

            <para>Finally, the initial navigation mode setting can be
            configured. The current valid mode names are <quote>Walk</quote>
            and <quote>Fly,</quote> and the use of this property simply
            indicates what navigation mode the user will be in when the
            application is started. See <xref
            linkend="section.vrkit.plugins.wandnav" /> for more details on
            this plug-in.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.plugin.wand.nav"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.wand.nav"></indexterm>
         </section>

         <section id="section.vrkit.plugins.viewer.widget">
            <title>Widget Plug-in</title>

            <indexterm class="startofrange"
                       id="index.section.plugin.viewer.widget">
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Widget</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.WidgetPlugin</literal> or
                     <literal>WidgetPlugin</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/WidgetPlugin.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/WidgetPlugin.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\WidgetPlugin.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para></para>

            <indexterm class="endofrange"
                       startref="index.section.plugin.viewer.widget"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.plugin.viewer"></indexterm>
         </section>
      </section>

      <section id="section.vrkit.plugins.strategy.isect">
         <title>Intersection Strategy Plug-ins</title>

         <para>The base vrkit application class performs intersection tests
         and reports the results to all interested parties if an intersection
         strategy is configured (see <xref
         linkend="section.config.vrkit.viewer" />). The intersection test
         algorithm that is used comes from a dynamically loaded strategy
         plug-in. In this section, we explain the available intersection
         strategies.</para>

         <section id="section.vrkit.strategy.isect.point">
            <title>Point Intersection Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.strategy.isect.point">
               <primary>plug-ins</primary>

               <secondary>intersection strategy</secondary>

               <tertiary>Point Intersection</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.isect.PointIntersectionStrategy</literal>
                     or <literal>Point Intersection</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/isect/PointIntersection.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/isect/PointIntersection.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\isect\PointIntersection.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Point Intersection strategy requires that the wand be
            within the bounding volume (an axis-aligned bounding box) of the
            object that is to be grabbed or chosen for grabbing. This
            intersection strategy is useful for cases when a sense of direct
            object interaction is desired or when using the Ray Intersection
            strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>intersection strategy</secondary>

                  <tertiary>Ray Intersection</tertiary>
               </indexterm> is not possible.</para>

            <indexterm class="endofrange"
                       startref="index.section.strategy.isect.point"></indexterm>
         </section>

         <section id="section.vrkit.strategy.isect.ray">
            <title>Ray Intersection Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.strategy.isect.ray">
               <primary>plug-ins</primary>

               <secondary>intersection strategy</secondary>

               <tertiary>Ray Intersection</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier:
                     <literal>com.infiscape.isect.RayIntersectionStrategy</literal>
                     or <literal>Ray Intersection</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/isect/RayIntersection.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/isect/RayIntersection.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\isect\RayIntersection.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>ray_intersection_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Ray Intersection strategy uses ray/volume and
            ray/triangle intersection tests to perform its job. A ray with an
            origin at the position of the wand and a direction vector pointing
            out of the front of the wand is used for this purpose. For
            efficiency reasons, the intersection testing is done using a
            two-phase process wherein known non-intersecting objects are
            removed using the fast ray/volume test. Then, to get more precise
            results, triangle-level intersection tests can be performed if the
            strategy is so configured. The use of a ray for intersection tests
            allows for <quote>remote</quote> interaction with distant
            objects.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.strategy.isect.ray">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Ray Intersection Strategy</tertiary>
            </indexterm>

            <para>The strategy itself will render a line segement, a visual
            representation of a mathematical ray, in the scene as a visual aid
            to the application user. In mathematics, a ray has a starting
            point and a direction, and it has infinite length and infinitely
            small width. For the purposes of this application, however, the
            ray rendered in the scene has a finite length and a measurable
            width. These are the first two configurable properties of the Ray
            Intersection strategy. The rendered ray length is measured in
            feet, and its width is measured in pixels<footnote>
                  <para>Rendering lines with OpenGL requires some care.
                  Different displays may result in variation in the appearance
                  of the lines. In particular, differences in pixels sizes can
                  cause the ray to appear too fat or too thin. Some tweaking
                  of the ray width may be necessary to get the ray to have a
                  good appearance. The line used for rendering the ray does
                  not use anti-aliasing by default, so it may appear
                  jagged.</para>
               </footnote>. Real number values are used for both, meaning that
            fractional values can be used easily.</para>

            <para>Next, the color of the ray is configured by setting the
            diffuse and ambient color values. Both of these are RGB colors,
            and the component color values must be in the range [0.0, 1.0]. In
            general, it is recommended that the ambient and diffuse colors be
            the same. The default is to use red for both.</para>

            <para>Finally, we can make one adjustment to the intersection
            algorithm used by this intersection strategy, but before we
            explain that, we must provide some background on how intersection
            tests are performed by this code. In order to reduce the
            computational complexity of the intersection tests, fast tests are
            performed against the ray and the (axis-aligned) bounding volumes
            of the objects in the scene that allow/support intersection. This
            test is performed against all the objects in the scene, and the
            one whose intersected bounding volume is closest to the user is
            the one identified as being intersected. After that, the test can
            be refined to do triangle-level intersections with the ray and the
            individual triangles of the intersected object. This is a more
            computationally expensive operation, but it prevents false
            positives from occurring. For example, the bounding volumeâ€”an
            axis-aligned boxâ€”for a given object may have a great deal of empty
            space depending on its size and shape. In many circumstances, the
            ray may intersect the bounding volume but not intersect any
            component of the actual geometry of such an object. Triangle-level
            intersection tests address this case as well as other more complex
            intersections where a bounding volume test is simply
            insufficiently specific.</para>

            <para>Depending on the needs of the application and the geometry
            being used, a decision must be made regarding whether to use
            triangle-level intersection tests to refine the results of this
            intersection strategy. With modern computers, the triangle-level
            intersections do not normally consume much CPU time. For a
            sufficiently complex piece of geometry with many polygons,
            however, these tests could reduce the overall frame rate. With
            that in mind, it is recommended that triangle-level intersection
            tests be used except in cases where they prove to be too
            costly.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.strategy.isect.ray"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.strategy.isect.ray"></indexterm>
         </section>
      </section>

      <section id="section.grab.strategy.plugins">
         <title>Grab Strategy Plug-ins</title>

         <para>The grab strategies used by the vrkit Grab Plug-in are
         dynamically loaded plug-ins. Here, we describe the available grab
         strategies very briefly. The one to choose for use by the Grab
         Plug-in<indexterm>
               <primary>plug-ins</primary>

               <secondary>viewer</secondary>

               <tertiary>Grab</tertiary>
            </indexterm> (or some other plug-in that can make use of vrkit
         grab strategy plug-ins) depends on the needs of the application. In
         all cases of the plug-ins listed below, an object must be
         interesected before it can be grabbed. This is done using an
         intersection strategy plug-in, and more information about such
         plug-ins can be found in <xref
         linkend="section.config.vrkit.viewer" /> and in <xref
         linkend="section.vrkit.plugins.strategy.isect" />.</para>

         <section id="section.vrkit.strategy.grab.multi">
            <title>Multi-Object Grab Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.grab.multi">
               <primary>plug-ins</primary>

               <secondary>grab strategy</secondary>

               <tertiary>Multi-Object Grab</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Multi-Object
                     Grab</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/MultiObjectGrab.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/MultiObjectGrab.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\grab\MultiObjectGrab.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>multi_object_grab_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The multi-object grab strategy allows multiple objects to be
            grabbed simultaneously. This is done by breaking object grabbing
            into three different actions: choose, grab, and release. An object
            is chosen for grabbing by intersecting it and then performing the
            choose operation. This adds the object to the current collection
            of chosen objects. Once the objects have been chosen, the grab
            operation can be performed so that the objects now move relative
            to the movement of the wand. Finally, the user can let go of the
            grabbed objects by performing the release operation. It is
            possible to bypass the choose step by performing the grab
            operation on the object that is currently intersected. In this
            case, that object will be the only one that is grabbed.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.strategy.grab.multi">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Multi-Object Grab Strategy</tertiary>
            </indexterm>

            <para>Given that there are three operations that can be performed
            using this grab strategy, there are three configurable actions
            handled by this strategy. These actions are as follows: choosing
            objects to grab, grabbing selected objects, and releasing grabbed
            objects. Each is configured using a digital command
            expression<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> (see <xref
            linkend="section.digital.commands" />).</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.strategy.grab.multi"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.grab.multi"></indexterm>
         </section>

         <section id="section.vrkit.strategy.grab.single">
            <title>Single Object Grab Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.grab.single">
               <primary>plug-ins</primary>

               <secondary>grab strategy</secondary>

               <tertiary>Single Object Grab</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Single Object
                     Grab</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/SingleObjectGrab.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/SingleObjectGrab.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\grab\SingleObjectGrab.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>single_object_grab_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <indexterm class="startofrange"
                       id="index.config.vrkit.strategy.grab.single">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Single Object Grab Strategy</tertiary>
            </indexterm>

            <para>The single object grab strategy allows one object at a time
            to be grabbed. There are two configurable actions handled by this
            strategy: grabbing and releasing. These are each configured using
            a digital command expression<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> (see <xref
            linkend="section.digital.commands" />).</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.strategy.grab.single"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.grab.single"></indexterm>
         </section>

         <section id="section.vrkit.strategy.grab.signal">
            <title>Signal-Based Grab Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.grab.signal">
               <primary>plug-ins</primary>

               <secondary>grab strategy</secondary>

               <tertiary>Signal-Based Grab</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Signal-Based
                     Grab</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/SignalGrab.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/grab/SignalGrab.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\grab\SignalGrab.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>single_object_grab_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The signal-based grab strategy does not make decisions about
            what object(s) to grab. Instead, it emits signals based on events
            (choose, grab, and release) so that other code can make the
            decisions about what to do. This allows for a high degree of
            flexibility because the choose, grab, and release algorithms are
            decoupled from the strategy and are not put in place until run
            time. At the same time, it requires that other code be in place to
            respond to the emitted signals. As a consequence, this grab
            strategy cannot be used in a generic application such as
            <command>vrkit_app</command> without loading another plug-in that
            will handle the signals emitted by this grab strategy.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.strategy.grab.signal">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Signal-Based Grab Strategy</tertiary>
            </indexterm>

            <para>There are three configurable actions handled by this
            strategy: choosing objects to grab, grabbing selected objects, and
            releasing grabbed objects. These are each configured using a
            digital command expression<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> (see <xref linkend="section.digital.commands" />).
            It is possible to forgo the use of any of these actions by
            configuring them to use an empty digital command
            expression.</para>

            <para>The configuration of the Signal-Based Grab
            strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>grab strategy</secondary>

                  <tertiary>Signal-Based Grab</tertiary>
               </indexterm> (using a config element of type
            <literal>signal_grab_strategy</literal>) is limited to the digital
            command expressions<indexterm>
                  <primary>digital command expression</primary>
               </indexterm> used for the three actions supported by this
            plug-in: selecting objects to grab, grabbing selected objects, and
            releasing grabbed objects. This is configured in the same basic
            way as the navigation action settings. That is, a digital command
            expression is used for each action. Please refer to <xref
            linkend="section.digital.commands" /> for details on how to
            configure digital commands. Note that if the grab and release
            actions are configured to use the same digital input, then those
            actions will be treated as a toggled state. That is, once objects
            are grabbed, the next time that digital input is activated, the
            grabbed objects will be released.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.strategy.grab.signal"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.grab.signal"></indexterm>
         </section>
      </section>

      <section id="section.move.strategy.plugins">
         <title>Move Strategy Plug-ins</title>

         <para>The move strategies used by the vrkit Grab Plug-in are
         dynamically loaded plug-ins. Here, we describe the available move
         strategies very briefly. Note that, in general, using the Basic Move
         strategy<indexterm>
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Basic Move</tertiary>
            </indexterm> is appropriate for
         <command>vrkit_app</command>.</para>

         <section id="section.vrkit.strategy.move.basic">
            <title>Basic Move Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.move.basic">
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Basic Move</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Basic Move</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/BasicMove.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/BasicMove.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\move\BasicMove.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The movement algorithm used by the Basic Move strategy keeps
            the relative location of the wand and the grabbed object(s)
            constant based on when the grab operation occurred. This allows,
            for example, rotation around the grab point rather than being
            limited to the center point of the grabbed object. This behavior
            is appropriate for composition with all grab and intersection
            strategies currently provided with vrkit.</para>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.move.basic"></indexterm>
         </section>

         <section id="section.vrkit.strategy.move.center">
            <title>Center Point Move Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.move.center">
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Center Point Move</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Center Point
                     Move</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/CenterPointMove.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/CenterPointMove.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\move\CenterPointMove.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The movement algorithm used by the Center Point Move
            strategy is very simple and simply snaps the center point of the
            object to the wand (hand) position when the grab operation is
            performed. The grabbed object is then rotated and positioned
            relative to its center point. This behavior is generally not
            appropriate for mixing with the Ray Intersection
            strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>intersection strategy</secondary>

                  <tertiary>Ray Intersection</tertiary>
               </indexterm> since the point of intersection on the ray is
            lost.</para>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.move.center"></indexterm>
         </section>

         <section id="section.vrkit.strategy.move.slide.simple">
            <title>Simple Slide Move Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.move.slide.simple">
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Simple Slide Move</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Simple Slide
                     Move</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/SimpleSlideMove.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/SimpleSlideMove.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\move\SimpleSlideMove.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>simple_slide_move_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <para>The Simple Slide Move strategy allows grabbed objects to be
            moved closer to or further away from the user along an axis using
            analog input. This is useful in conjunction with the Ray
            Intersection strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>intersection strategy</secondary>

                  <tertiary>Ray Intersection</tertiary>
               </indexterm> in order to allow for grabbing of distant objects
            and then moving them close to the user without navigation. Analog
            input is required for this strategy to do its job.</para>

            <indexterm class="startofrange"
                       id="index.config.vrkit.strategy.move.simple.slide">
               <primary>configuration</primary>

               <secondary>vrkit</secondary>

               <tertiary>Simple Slide Move Strategy</tertiary>
            </indexterm>

            <para>The Simple Slide Move strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>move strategy</secondary>

                  <tertiary>Simple Slide Move</tertiary>
               </indexterm> is configured using a config element of type
            <literal>simple_slide_move_strategy</literal>. Recall that this is
            composed with other move strategies by the vrkit Grab
            Plug-in<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>vrkit</secondary>

                  <tertiary>Grab</tertiary>
               </indexterm>. There are only a few properties for the Simple
            Slide Move strategy config element.</para>

            <para>The first configurable property identifies where the
            strategy gets analog input for the sliding operation. Recall from
            <xref linkend="section.config.vrkit.wand.interface" /> that an
            analog input is identified by an integer value. By default, this
            must be in the range 0 through 3, but the wand interface<indexterm>
                  <primary>wand interface</primary>
               </indexterm> can be configured to use any number of analog
            inputs. Game controllers often have two or more joysticks, each
            providing two analog axes. The means by which this is configured
            depends on the available input device(s) and the existing VR
            Juggler configuration. The use of the proxy aliases such as
            VJAnalog0 or VJAnalog3 offers a great deal of flexibility in how
            the collection of analog inputs provided by a single device can be
            handled. As always, much more detail on this topic can be found in
            the <ulink
            url="http://www.infiscape.com/documentation/vrjuggler-config/2.2/configuring_vr_juggler">VR
            Juggler 2.2 <emphasis>Configuration Guide</emphasis></ulink>. In
            some cases, no analog input source may be available for invoking
            the object sliding action. In that case, it is necessary to
            disable the object sliding feature of the ray grabber. We will
            explain why this is necessary below, but the important point is to
            be aware that it is possible to disable the sliding feature using
            a value of -1 for the analog input identifier.</para>

            <para>Next, the forward value of the object sliding feature can be
            configured. Variation has been observed in the data range returned
            by joysticks, and this aspect of the configuration strives to
            capture that variation. For example, the joystick on a game
            controller will return values in the range [-N, N] with 0.0 being
            the at-rest value. Pushing the joystick forward (away from the
            user) returns values in the range (0.0, N]; pulling the joystick
            back (toward the user) returns values in the range [-N, 0.0). On
            the other hand, the joystick on an InterSense
            <productname>IS-900</productname> wand behaves in the opposite
            manner. When pushed forward, it returns data in the range [-N,
            0.0) and vice versa when pulled back.</para>

            <para>Since it makes the most sense for objects to be slid away
            from the user when the joystick is pushed forward (and slid closer
            when pulled back), this move strategy allows the user to set the
            forward direction value to either 0.0 or 1.0. These two values are
            chosen because they are the minimum and maximum values returned by
            analog data sources to VR Juggler applications. This also means
            that the at-rest value of the physical analog input device must be
            midway between its minimum and maximum values. Fortunately, this
            is the case for joysticks as they are handled by <productname
            class="registered">Microsoft Windows</productname> and by
            Linux.</para>

            <para>To summarize, the forward value for object sliding can be
            set to 0.0 or 1.0. For the InterSense
            <productname>IS-900</productname> joystick, it should be set to
            0.0; for a game controller joystick, it should be set to 1.0.
            Other devices would require experimentation to determine what
            setting should be used.</para>

            <para>Next, the slide threshold can be configured to adjust how
            large the value returned by the analog input source must be before
            the grabbed object(s) will begin sliding. In some sense, this
            determines how much inertia must be overcome before sliding
            begins, though mass and friction are not factored into the
            decision.</para>

            <para>Finally, an acceleration multiplier can be set to determine
            how far an object slides each frame. The algorithm used by the
            Simple Slide Move strategy applies cumulative sliding. Thus, the
            longer an object slides, the faster it slides. The acceleration
            multiplier influences how fast this acceleration will occur. The
            value set in this property is multiplied by the
            application-specific scale factor (indicating the conversion to
            meters scaling), and the result is added to the current
            accumulated slide translation value. Ultimately, what this means
            is that a larger value causes objects to slide faster and to
            accumulate velocity faster. A smaller value causes objects to
            slide more slowly and to accumulate velocity less rapidly.</para>

            <indexterm class="endofrange"
                       startref="index.config.vrkit.strategy.move.simple.slide"></indexterm>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.move.slide.simple"></indexterm>
         </section>

         <section id="section.vrkit.strategy.move.slide">
            <title>Slide Move Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.move.slide">
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Slide Move</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Slide Move</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/SlideMove.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/SlideMove.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\move\SlideMove.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type:
                     <literal>slide_move_strategy</literal></para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <warning>
               <para>This movement strategy is currently non-functional and
               should not be used. Use the Simple Slide Move
               strategy<indexterm>
                     <primary>plug-ins</primary>

                     <secondary>move strategy</secondary>

                     <tertiary>Simple Slide Move</tertiary>
                  </indexterm> instead.</para>
            </warning>

            <para>The Slide Move strategy allows grabbed objects to be moved
            closer to or further away from the user along an axis using analog
            input. This is useful in conjunction with the Ray Intersection
            strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>intersection strategy</secondary>

                  <tertiary>Ray Intersection</tertiary>
               </indexterm> in order to allow for grabbing of distant objects
            and then moving them close to the user without navigation. Analog
            input is required for this strategy to do its job.</para>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.move.slide"></indexterm>
         </section>

         <section id="section.vrkit.strategy.move.object.space">
            <title>Object Space Move Strategy</title>

            <indexterm class="startofrange"
                       id="index.section.vrkit.strategy.move.object.space">
               <primary>plug-ins</primary>

               <secondary>move strategy</secondary>

               <tertiary>Object Space Move</tertiary>
            </indexterm>

            <highlights>
               <itemizedlist>
                  <listitem>
                     <para>Identifier: <literal>Object Space
                     Move</literal></para>
                  </listitem>

                  <listitem>
                     <para>File:</para>

                     <itemizedlist>
                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/ObjectSpaceMove.so</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>$VRKIT_PLUGINS_DIR/move/ObjectSpaceMove.dylib</filename></para>
                        </listitem>

                        <listitem>
                           <para><filename>%VRKIT_PLUGINS_DIR%\move\ObjectSpaceMove.dll</filename></para>
                        </listitem>
                     </itemizedlist>
                  </listitem>

                  <listitem>
                     <para>Config element type: None (not configurable)</para>
                  </listitem>
               </itemizedlist>
            </highlights>

            <warning>
               <para>This move strategy is still (mathematically) unstable and
               should not be used except for testing or evaluation
               purposes.</para>
            </warning>

            <para>The Object Space Move strategy is intended for use in
            conjunction with the Ray Intersection strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>intersection strategy</secondary>

                  <tertiary>Ray Intersection</tertiary>
               </indexterm> or some other intersection strategy where remote
            object operations are the norm. Using this move strategy causes
            the distant object to be transformed and rotated as though it were
            positioned at the location of the wand. Translations still happen
            in the same manner as with the Basic Move strategy<indexterm>
                  <primary>plug-ins</primary>

                  <secondary>move strategy</secondary>

                  <tertiary>Basic Move</tertiary>
               </indexterm>, but rotations are performed in the coordinate
            frame of the object. This prevents a very distant object from
            being transformed significantly when small wand rotations
            occur.</para>

            <indexterm class="endofrange"
                       startref="index.section.vrkit.strategy.move.object.space"></indexterm>
         </section>
      </section>
   </chapter>

   <chapter>
      <title><command>vrkit_app</command> Features and Configuration</title>

      <para></para>
   </chapter>

   <appendix id="appendix.gfdl">
      <title>GNU Free Documentation License</title>

      <subtitle>Version 1.2, November 2002</subtitle>

      <blockquote id="fsf-copyright">
         <title>FSF Copyright note</title>

         <para>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 59
         Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
         permitted to copy and distribute verbatim copies of this license
         document, but changing it is not allowed.</para>
      </blockquote>

      <section id="gfdl-0">
         <title>PREAMBLE</title>

         <para>The purpose of this License is to make a manual, textbook, or
         other functional and useful document "free" in the sense of freedom:
         to assure everyone the effective freedom to copy and redistribute it,
         with or without modifying it, either commercially or noncommercially.
         Secondarily, this License preserves for the author and publisher a
         way to get credit for their work, while not being considered
         responsible for modifications made by others.</para>

         <para>This License is a kind of "copyleft", which means that
         derivative works of the document must themselves be free in the same
         sense. It complements the GNU General Public License, which is a
         copyleft license designed for free software.</para>

         <para>We have designed this License in order to use it for manuals
         for free software, because free software needs free documentation: a
         free program should come with manuals providing the same freedoms
         that the software does. But this License is not limited to software
         manuals; it can be used for any textual work, regardless of subject
         matter or whether it is published as a printed book. We recommend
         this License principally for works whose purpose is instruction or
         reference.</para>
      </section>

      <section id="gfdl-1">
         <title>APPLICABILITY AND DEFINITIONS</title>

         <para id="gfdl-doc">This License applies to any manual or other work,
         in any medium, that contains a notice placed by the copyright holder
         saying it can be distributed under the terms of this License. Such a
         notice grants a world-wide, royalty-free license, unlimited in
         duration, to use that work under the conditions stated herein. The
         "Document", below, refers to any such manual or work. Any member of
         the public is a licensee, and is addressed as "you". You accept the
         license if you copy, modify or distribute the work in a way requiring
         permission under copyright law.</para>

         <para id="gfdl-mod-ver">A "Modified Version" of the Document means
         any work containing the Document or a portion of it, either copied
         verbatim, or with modifications and/or translated into another
         language.</para>

         <para id="gfdl-secnd-sect">A "Secondary Section" is a named appendix
         or a front-matter section of the Document that deals exclusively with
         the relationship of the publishers or authors of the Document to the
         Document's overall subject (or to related matters) and contains
         nothing that could fall directly within that overall subject. (Thus,
         if the Document is in part a textbook of mathematics, a Secondary
         Section may not explain any mathematics.) The relationship could be a
         matter of historical connection with the subject or with related
         matters, or of legal, commercial, philosophical, ethical or political
         position regarding them.</para>

         <para id="gfdl-inv-sect">The "Invariant Sections" are certain
         Secondary Sections whose titles are designated, as being those of
         Invariant Sections, in the notice that says that the Document is
         released under this License. If a section does not fit the above
         definition of Secondary then it is not allowed to be designated as
         Invariant. The Document may contain zero Invariant Sections. If the
         Document does not identify any Invariant Sections then there are
         none.</para>

         <para id="gfdl-cov-text">The "Cover Texts" are certain short passages
         of text that are listed, as Front-Cover Texts or Back-Cover Texts, in
         the notice that says that the Document is released under this
         License. A Front-Cover Text may be at most 5 words, and a Back-Cover
         Text may be at most 25 words.</para>

         <para id="gfdl-transparent">A "Transparent" copy of the Document
         means a machine-readable copy, represented in a format whose
         specification is available to the general public, that is suitable
         for revising the document straightforwardly with generic text editors
         or (for images composed of pixels) generic paint programs or (for
         drawings) some widely available drawing editor, and that is suitable
         for input to text formatters or for automatic translation to a
         variety of formats suitable for input to text formatters. A copy made
         in an otherwise Transparent file format whose markup, or absence of
         markup, has been arranged to thwart or discourage subsequent
         modification by readers is not Transparent. An image format is not
         Transparent if used for any substantial amount of text. A copy that
         is not "Transparent" is called "Opaque".</para>

         <para>Examples of suitable formats for Transparent copies include
         plain ASCII without markup, Texinfo input format, LaTeX input format,
         SGML or XML using a publicly available DTD, and standard-conforming
         simple HTML, PostScript or PDF designed for human modification.
         Examples of transparent image formats include PNG, XCF and JPG.
         Opaque formats include proprietary formats that can be read and
         edited only by proprietary word processors, SGML or XML for which the
         DTD and/or processing tools are not generally available, and the
         machine-generated HTML, PostScript or PDF produced by some word
         processors for output purposes only.</para>

         <para id="gfdl-title-page">The "Title Page" means, for a printed
         book, the title page itself, plus such following pages as are needed
         to hold, legibly, the material this License requires to appear in the
         title page. For works in formats which do not have any title page as
         such, "Title Page" means the text near the most prominent appearance
         of the work's title, preceding the beginning of the body of the
         text.</para>

         <para id="gfdl-entitled">A section "Entitled XYZ" means a named
         subunit of the Document whose title either is precisely XYZ or
         contains XYZ in parentheses following text that translates XYZ in
         another language. (Here XYZ stands for a specific section name
         mentioned below, such as "Acknowledgements", "Dedications",
         "Endorsements", or "History".) To "Preserve the Title" of such a
         section when you modify the Document means that it remains a section
         "Entitled XYZ" according to this definition.</para>

         <para>The Document may include Warranty Disclaimers next to the
         notice which states that this License applies to the Document. These
         Warranty Disclaimers are considered to be included by reference in
         this License, but only as regards disclaiming warranties: any other
         implication that these Warranty Disclaimers may have is void and has
         no effect on the meaning of this License.</para>
      </section>

      <section id="gfdl-2">
         <title>VERBATIM COPYING</title>

         <para>You may copy and distribute the Document in any medium, either
         commercially or noncommercially, provided that this License, the
         copyright notices, and the license notice saying this License applies
         to the Document are reproduced in all copies, and that you add no
         other conditions whatsoever to those of this License. You may not use
         technical measures to obstruct or control the reading or further
         copying of the copies you make or distribute. However, you may accept
         compensation in exchange for copies. If you distribute a large enough
         number of copies you must also follow the conditions in section
         3.</para>

         <para>You may also lend copies, under the same conditions stated
         above, and you may publicly display copies.</para>
      </section>

      <section id="gfdl-3">
         <title>COPYING IN QUANTITY</title>

         <para>If you publish printed copies (or copies in media that commonly
         have printed covers) of the Document, numbering more than 100, and
         the Document's license notice requires Cover Texts, you must enclose
         the copies in covers that carry, clearly and legibly, all these Cover
         Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
         the back cover. Both covers must also clearly and legibly identify
         you as the publisher of these copies. The front cover must present
         the full title with all words of the title equally prominent and
         visible. You may add other material on the covers in addition.
         Copying with changes limited to the covers, as long as they preserve
         the title of the Document and satisfy these conditions, can be
         treated as verbatim copying in other respects.</para>

         <para>If the required texts for either cover are too voluminous to
         fit legibly, you should put the first ones listed (as many as fit
         reasonably) on the actual cover, and continue the rest onto adjacent
         pages.</para>

         <para>If you publish or distribute Opaque copies of the Document
         numbering more than 100, you must either include a machine-readable
         Transparent copy along with each Opaque copy, or state in or with
         each Opaque copy a computer-network location from which the general
         network-using public has access to download using public-standard
         network protocols a complete Transparent copy of the Document, free
         of added material. If you use the latter option, you must take
         reasonably prudent steps, when you begin distribution of Opaque
         copies in quantity, to ensure that this Transparent copy will remain
         thus accessible at the stated location until at least one year after
         the last time you distribute an Opaque copy (directly or through your
         agents or retailers) of that edition to the public.</para>

         <para>It is requested, but not required, that you contact the authors
         of the Document well before redistributing any large number of
         copies, to give them a chance to provide you with an updated version
         of the Document.</para>
      </section>

      <section id="gfdl-4">
         <title>MODIFICATIONS</title>

         <para>You may copy and distribute a Modified Version of the Document
         under the conditions of sections 2 and 3 above, provided that you
         release the Modified Version under precisely this License, with the
         Modified Version filling the role of the Document, thus licensing
         distribution and modification of the Modified Version to whoever
         possesses a copy of it. In addition, you must do these things in the
         Modified Version:</para>

         <orderedlist id="gfdl-modif-cond" numeration="upperalpha">
            <title>GNU FDL Modification Conditions</title>

            <listitem>
               <simpara>Use in the Title Page (and on the covers, if any) a
               title distinct from that of the Document, and from those of
               previous versions (which should, if there were any, be listed
               in the History section of the Document). You may use the same
               title as a previous version if the original publisher of that
               version gives permission.</simpara>
            </listitem>

            <listitem>
               <simpara>List on the Title Page, as authors, one or more
               persons or entities responsible for authorship of the
               modifications in the Modified Version, together with at least
               five of the principal authors of the Document (all of its
               principal authors, if it has fewer than five), unless they
               release you from this requirement.</simpara>
            </listitem>

            <listitem>
               <simpara>State on the Title page the name of the publisher of
               the Modified Version, as the publisher.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve all the copyright notices of the
               Document.</simpara>
            </listitem>

            <listitem>
               <simpara>Add an appropriate copyright notice for your
               modifications adjacent to the other copyright
               notices.</simpara>
            </listitem>

            <listitem>
               <simpara>Include, immediately after the copyright notices, a
               license notice giving the public permission to use the Modified
               Version under the terms of this License, in the form shown in
               the <link linkend="gfdl-addendum">Addendum</link>
               below.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve in that license notice the full lists of
               Invariant Sections and required Cover Texts given in the
               Document's license notice.</simpara>
            </listitem>

            <listitem>
               <simpara>Include an unaltered copy of this License.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve the section Entitled "History", Preserve its
               Title, and add to it an item stating at least the title, year,
               new authors, and publisher of the Modified Version as given on
               the Title Page. If there is no section Entitled "History" in
               the Document, create one stating the title, year, authors, and
               publisher of the Document as given on its Title Page, then add
               an item describing the Modified Version as stated in the
               previous sentence.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve the network location, if any, given in the
               Document for public access to a Transparent copy of the
               Document, and likewise the network locations given in the
               Document for previous versions it was based on. These may be
               placed in the "History" section. You may omit a network
               location for a work that was published at least four years
               before the Document itself, or if the original publisher of the
               version it refers to gives permission.</simpara>
            </listitem>

            <listitem>
               <simpara>For any section Entitled "Acknowledgements" or
               "Dedications", Preserve the Title of the section, and preserve
               in the section all the substance and tone of each of the
               contributor acknowledgements and/or dedications given
               therein.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve all the Invariant Sections of the Document,
               unaltered in their text and in their titles. Section numbers or
               the equivalent are not considered part of the section
               titles.</simpara>
            </listitem>

            <listitem>
               <simpara>Delete any section Entitled "Endorsements". Such a
               section may not be included in the Modified Version.</simpara>
            </listitem>

            <listitem>
               <simpara>Do not retitle any existing section to be Entitled
               "Endorsements" or to conflict in title with any Invariant
               Section.</simpara>
            </listitem>

            <listitem>
               <simpara>Preserve any Warranty Disclaimers.</simpara>
            </listitem>
         </orderedlist>

         <para>If the Modified Version includes new front-matter sections or
         appendices that qualify as Secondary Sections and contain no material
         copied from the Document, you may at your option designate some or
         all of these sections as invariant. To do this, add their titles to
         the list of Invariant Sections in the Modified Version's license
         notice. These titles must be distinct from any other section
         titles.</para>

         <para>You may add a section Entitled "Endorsements", provided it
         contains nothing but endorsements of your Modified Version by various
         parties--for example, statements of peer review or that the text has
         been approved by an organization as the authoritative definition of a
         standard.</para>

         <para>You may add a passage of up to five words as a Front-Cover
         Text, and a passage of up to 25 words as a Back-Cover Text, to the
         end of the list of Cover Texts in the Modified Version. Only one
         passage of Front-Cover Text and one of Back-Cover Text may be added
         by (or through arrangements made by) any one entity. If the Document
         already includes a cover text for the same cover, previously added by
         you or by arrangement made by the same entity you are acting on
         behalf of, you may not add another; but you may replace the old one,
         on explicit permission from the previous publisher that added the old
         one.</para>

         <para>The author(s) and publisher(s) of the Document do not by this
         License give permission to use their names for publicity for or to
         assert or imply endorsement of any Modified Version.</para>
      </section>

      <section id="gfdl-5">
         <title>COMBINING DOCUMENTS</title>

         <para>You may combine the Document with other documents released
         under this License, under the terms defined in <link
         linkend="gfdl-4">section 4</link> above for modified versions,
         provided that you include in the combination all of the Invariant
         Sections of all of the original documents, unmodified, and list them
         all as Invariant Sections of your combined work in its license
         notice, and that you preserve all their Warranty Disclaimers.</para>

         <para>The combined work need only contain one copy of this License,
         and multiple identical Invariant Sections may be replaced with a
         single copy. If there are multiple Invariant Sections with the same
         name but different contents, make the title of each such section
         unique by adding at the end of it, in parentheses, the name of the
         original author or publisher of that section if known, or else a
         unique number. Make the same adjustment to the section titles in the
         list of Invariant Sections in the license notice of the combined
         work.</para>

         <para>In the combination, you must combine any sections Entitled
         "History" in the various original documents, forming one section
         Entitled "History"; likewise combine any sections Entitled
         "Acknowledgements", and any sections Entitled "Dedications". You must
         delete all sections Entitled "Endorsements".</para>
      </section>

      <section id="gfdl-6">
         <title>COLLECTIONS OF DOCUMENTS</title>

         <para>You may make a collection consisting of the Document and other
         documents released under this License, and replace the individual
         copies of this License in the various documents with a single copy
         that is included in the collection, provided that you follow the
         rules of this License for verbatim copying of each of the documents
         in all other respects.</para>

         <para>You may extract a single document from such a collection, and
         distribute it individually under this License, provided you insert a
         copy of this License into the extracted document, and follow this
         License in all other respects regarding verbatim copying of that
         document.</para>
      </section>

      <section id="gfdl-7">
         <title>AGGREGATION WITH INDEPENDENT WORKS</title>

         <para>A compilation of the Document or its derivatives with other
         separate and independent documents or works, in or on a volume of a
         storage or distribution medium, is called an "aggregate" if the
         copyright resulting from the compilation is not used to limit the
         legal rights of the compilation's users beyond what the individual
         works permit. When the Document is included in an aggregate, this
         License does not apply to the other works in the aggregate which are
         not themselves derivative works of the Document.</para>

         <para>If the Cover Text requirement of section 3 is applicable to
         these copies of the Document, then if the Document is less than one
         half of the entire aggregate, the Document's Cover Texts may be
         placed on covers that bracket the Document within the aggregate, or
         the electronic equivalent of covers if the Document is in electronic
         form. Otherwise they must appear on printed covers that bracket the
         whole aggregate.</para>
      </section>

      <section id="gfdl-8">
         <title>TRANSLATION</title>

         <para>Translation is considered a kind of modification, so you may
         distribute translations of the Document under the terms of section 4.
         Replacing Invariant Sections with translations requires special
         permission from their copyright holders, but you may include
         translations of some or all Invariant Sections in addition to the
         original versions of these Invariant Sections. You may include a
         translation of this License, and all the license notices in the
         Document, and any Warranty Disclaimers, provided that you also
         include the original English version of this License and the original
         versions of those notices and disclaimers. In case of a disagreement
         between the translation and the original version of this License or a
         notice or disclaimer, the original version will prevail.</para>

         <para>If a section in the Document is Entitled "Acknowledgements",
         "Dedications", or "History", the requirement (section 4) to Preserve
         its Title (section 1) will typically require changing the actual
         title.</para>
      </section>

      <section id="gfdl-9">
         <title>TERMINATION</title>

         <para>You may not copy, modify, sublicense, or distribute the
         Document except as expressly provided for under this License. Any
         other attempt to copy, modify, sublicense or distribute the Document
         is void, and will automatically terminate your rights under this
         License. However, parties who have received copies, or rights, from
         you under this License will not have their licenses terminated so
         long as such parties remain in full compliance.</para>
      </section>

      <section id="gfdl-10">
         <title>FUTURE REVISIONS OF THIS LICENSE</title>

         <para>The Free Software Foundation may publish new, revised versions
         of the GNU Free Documentation License from time to time. Such new
         versions will be similar in spirit to the present version, but may
         differ in detail to address new problems or concerns. See
         http://www.gnu.org/copyleft/.</para>

         <para>Each version of the License is given a distinguishing version
         number. If the Document specifies that a particular numbered version
         of this License "or any later version" applies to it, you have the
         option of following the terms and conditions either of that specified
         version or of any later version that has been published (not as a
         draft) by the Free Software Foundation. If the Document does not
         specify a version number of this License, you may choose any version
         ever published (not as a draft) by the Free Software
         Foundation.</para>
      </section>

      <section id="gfdl-addendum">
         <title>ADDENDUM: How to use this License for your documents</title>

         <para>To use this License in a document you have written, include a
         copy of the License in the document and put the following copyright
         and license notices just after the title page:</para>

         <blockquote id="copyright-sample">
            <title>Sample Invariant Sections list</title>

            <para>Copyright (c) YEAR YOUR NAME. Permission is granted to copy,
            distribute and/or modify this document under the terms of the GNU
            Free Documentation License, Version 1.2 or any later version
            published by the Free Software Foundation; with no Invariant
            Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of
            the license is included in the section entitled "GNU Free
            Documentation License".</para>
         </blockquote>

         <para>If you have Invariant Sections, Front-Cover Texts and
         Back-Cover Texts, replace the "with...Texts." line with this:</para>

         <blockquote id="inv-cover-sample">
            <title>Sample Invariant Sections list</title>

            <para>with the Invariant Sections being LIST THEIR TITLES, with
            the Front-Cover Texts being LIST, and with the Back-Cover Texts
            being LIST.</para>
         </blockquote>

         <para>If you have Invariant Sections without Cover Texts, or some
         other combination of the three, merge those two alternatives to suit
         the situation.</para>

         <para>If your document contains nontrivial examples of program code,
         we recommend releasing these examples in parallel under your choice
         of free software license, such as the GNU General Public License, to
         permit their use in free software.</para>
      </section>
   </appendix>

   <index></index>
</book>